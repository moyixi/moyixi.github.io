<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="莫一兮的个人博客">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="莫一兮的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>莫一兮的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">莫一兮的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/" itemprop="url">模板方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-21T13:25:00+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 组件协作类模式<br> Template Method 模板方法<br>             ：某一项任务有整体的操作骨架，但各个子步骤有很多改变的需求，<br>                 或者由于固有的原因(比如框架和应用之间的关系)，而无法和任务的整体结构同时实现<br>                 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或晚期实现需求<br> <strong>定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中，Template Method使得子类可以复用一个算法的结构，</strong><br> <strong>同时可以重定义(Override重写)该算法的某些特定步骤。</strong><br> 重复代码全部在父类里面，不同业务的，通过抽象方法给子类实现，即在父类中实现骨架，子类中具体实现。<br>Template Method 之前都是App来调用 Lib 早绑定<br>实现之后就是 Lib调用App 晚绑定<br> 两种写法应用程序流程对比：<br> 【Lib】<br> 【App】<br> 【Lib】<br> 【App】<br> 【Lib】<br>结构化软件设计流程<br>Lib开发人员： 开发 1、3、5<br>App开发人员： 开发 2、4 和程序主流程</p>
<p>面向对象设计流程<br>Lib开发人员： 开发 1、3、5和程序主流程<br>App开发人员： 开发 2、4 </p>
<p>普通的开发模式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ordinary</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Library lib = <span class="keyword">new</span> Library();</span><br><span class="line"></span><br><span class="line">		Application app = <span class="keyword">new</span> Application();</span><br><span class="line">		<span class="comment">//在主函数中将步骤按某种顺序串联。流程中需要用到程序库开发人员同时也需要用到应用程序开发人员。</span></span><br><span class="line">		lib.step1();</span><br><span class="line">		<span class="keyword">if</span>(app.step2()==<span class="keyword">true</span>) &#123;</span><br><span class="line">			lib.step3();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">			app.step4();</span><br><span class="line">		&#125;</span><br><span class="line">		lib.step5();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Library</span></span>&#123;</span><br><span class="line">		<span class="comment">//程序库开发人员有完成某一项任务的1、3、5步骤</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"Ordinary step1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"Ordinary step3"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step5</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"Ordinary step5"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">		<span class="comment">//应用程序开发人员有某项任务的2、4步骤</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"Ordinary step4"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodLib</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//稳定 template method</span></span><br><span class="line">		<span class="comment">//前提：run 必须稳定，当做骨架可被重用</span></span><br><span class="line">		step1();</span><br><span class="line">		<span class="keyword">if</span>(step2()) &#123;<span class="comment">//支持变化</span></span><br><span class="line">			step3();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">			step4();<span class="comment">//支持变化</span></span><br><span class="line">		&#125;</span><br><span class="line">		step5();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Lib step1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Lib step3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">step5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Lib step5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">step2</span><span class="params">()</span> </span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">step4</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用程序开发人员继承Lib类，并重写step2、step4方法，Lib中的run方法是稳定的，step2、step4是变化的，可以修改的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodApp</span> <span class="keyword">extends</span> <span class="title">TemplateMethodLib</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"App step4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TemplateMethodLib tml = <span class="keyword">new</span> TemplateMethodApp();</span><br><span class="line">		tml.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/" itemprop="url">设计模式介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T18:31:35+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 编译时依赖：编译时需要你存在我才能编译通过<br> 什么是设计模式：<br> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心，这样就能一次又一次地使用该方案而不必做重复劳动<br> 可复用是设计模式的目标。<br> 面向对象是手法<br> 向下：深入理解三大面向对象机制<br> 封装、隐藏内部实现<br> 继承、复用现有代码<br> 多态、改写对象行为<br> 如何解决复杂性：<br> 分解：面对复杂些的常见做法：分而治之，但不好复用<br> 抽象：忽视非本质细节，而去处理泛化和理想化了的对象模型</p>
<p> 面向对象设计原则:<br> 变化是复用的天敌，面向对象设计最大的优势在于抵御变化。</p>
<p> 重新认识面向对象：<br> 理解隔离变化：</p>
<p> 从宏观层面来看，面向对象的够安静方式更能适应软件的变化，能将变化所带来的影响减为最小</p>
<p> 各司其职：<br> 从微观层面来看，面向对象的方式更强调各个类的责任，由于需求变化导致的新增类型不应该影响原来类型的实现—是所谓各负其责</p>
<p> 对象是什么：<br> 从语言实现层面来看，对象封装了代码和数据。<br> 从规格层面讲，对象是一系列可被使用的公共接口<br> 从概念层面讲，对象是某种拥有责任的抽象。</p>
<p> 面向对象设计原则<br> 1、依赖倒置原则(DIP)<br> 高层模块(稳定)不应该依赖于低层模块(变化),二者都应该依赖于抽象(稳定)</p>
<p> 抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)</p>
<p> 2、开放封闭原则(OCP)<br> 对扩展开放，对更改封闭<br> 类模块应该是可扩展的，但是不可修改</p>
<p> 3、单一职责原则(SRP)<br> 一个类应该仅有一个引起它变化的原因<br> 变化的方向隐含着类的责任</p>
<p> 4、Liskov[音：丽斯科夫]替换原则(LSP)<br> 子类必须能够替换它们的基类(IS-A)<br> 继承表达类型抽象</p>
<p> 5、接口隔离原则(ISP)<br> 不应该强迫客户程序依赖它们不用的方法<br> 接口应该小而完备(不要把不必要的方法 public出去)</p>
<p> 6、优先使用对象组合，而不是类继承<br> 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。<br> 继承在某种程度上破坏了封装性，子类父类耦合度高。<br> 而对象组合只要求被组合的对象具有良好定义的接口，耦合度低。</p>
<p> 7、封装变化点<br> 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改<br> 而不会对另一侧产生不良的影响，从而实现层次间的松耦合</p>
<p> 8、针对接口编程，而不是针对实现编程<br> 不将变量类型声明为某个特定的具体类，而是声明为某个接口<br> 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口<br> 减少系统中各部分的依赖关系，从而实现高内聚、松耦合的类型设计方案。</p>
<p>面向接口编程，接口标准化是产业强盛的标志<br>    GOF-23模式分类<br>    从目的来看：<br>    创建型模式<br>        解决对象创建的工作<br>    结构型模式<br>        应对需求变化为对象的结构带来的冲击<br>    行为型模式<br>        多个类之间交互过程中责任划分的问题<br>    从范围来看：<br>    类模式：<br>    类模式倾向类和子类的静态关系，偏重继承方案</p>
<pre><code>对象模式：
对象模式处理对象间的动态关系，偏重组合方案

设计模式的要点是：寻找变化点，在变化点处应用设计模式
重构关键技法：
静态-&gt;动态
早绑定-&gt;晚绑定
继承-&gt;组合
编译时依赖-&gt;运行时依赖
紧耦合-&gt;松耦合

从封装变化角度对模式分类
组件协作：
    通过晚期绑定来实现框架与应用之间的松耦合
    典型模式：
        Template Method 模板方法
                某一项任务有整体的操作骨架，但各个子步骤有很多改变的需求，
                或者由于固有的原因(比如框架和应用之间的关系)，而无法和任务的整体结构同时实现
                如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或晚期实现需求

        Strategy        策略模式
            动机：
            软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中
            将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担
            如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？
            定义一系列算法，把它们一个个封装起来，并且使他们可以互相替换(变化)。
            该模式是的算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)
        Observer/Event    观察者模式/事件模式
单一职责：
    在软件组件的设计中，如果责任划分的不清晰，使用继承得到的，结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码
    这时候的关键是划清责任
    典型模式：
            Decorator 装饰器模式
            主体操作和扩展操作分开分支继承
            动机：
                 某些情况下可能会过度的使用继承来扩展对象的功能，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性，并且随着子类的增多
                 (扩展功能的增多)各种子类的组合(扩展功能的组合)会导致更多子类的膨胀
             动态地给一个对象增加一些额外的职责，就增加功能而言，Decorator模式比生成子类(继承)更为灵活(消除重复代码&amp;减少子类个数)
            通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能
            避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
            Decorator类在接口上表现为 is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为
            has-a Component的组合关系，即Decorator类又使用了另外一个Component类。
            Decorator 模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”---是为装饰的含义

            Bridge 桥模式
                将抽象部分(业务功能)与实现部分(平台实现)分离，使他们都可以独立地变化。

                Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着
                各自维度的变化，即&quot;子类化&quot;它们

                Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则(即一个类只有一个变化的原因)，复用性比较差。
                Bridge模式时比多继承方案更好的解决方法。

                Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。
                有时候一个类有多个变化维度，此时可以把某一个聚合的变化维度合在一起，打包成一个基类，用一个抽象指针指向它。有n个变化维度，就打包n个基类，用n个抽象指针指向它。


对象创建：
    通过“对象创建”模式绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)，从而支持对象创建的稳定，他是接口抽象之后的第一步工作。
            Factory Method:工厂方法模式
                    在软件系统中经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。
                    定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method 使得一个类的实例化延迟(目的：解耦，手段：虚函数)到子类
                    Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系，面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱
                    Factory Method模式通过面向对象的手法（多态），将所要创建的具体对象工作延迟到子类，从而实现一种扩展(而非更改)的策略，较好地解决了这种紧耦合关系
                    Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同

            Abstract Factory:抽象工厂模式，和工厂方法模式是同一类模式
                    动机：软件系统中，经常面临着“一系列相互依赖的对象”的创建工作，同时由于需求的变化，往往存在更多系列对象的创建工作
                    提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定他们具体的类。
                    如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以
                    系列对象指的是在某一特定系列下的对象之间有相互依赖，或作用的关系，不同系列的对象之间不能相互依赖
                    Abstract Factory模式主要在于应对“新系列”的需求变动，其缺点在于难以应对“新对象”的需求变动
                        即加新系列很简单，但加新对象比较麻烦
            Prototype ：原型模式
                    动机：软件系统装，经常面临着“某些结构复杂的对象”的创建工作，由于需求的变化，这些对象经常面临着剧烈的变化，但他们拥有比较稳定一致的接口
                    Prototype模式同样用于隔离类对象的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些易变类拥有稳定的接口
                    Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象
                    所需工作仅是注册一个新类的对象(即原型)然后再任何需要的地方Clone
                    Prototype模式中的Clone方法可以利用某些框架的序列化来实现深拷贝。
            Builder：构建器
                    动机：在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成，由于需求的变化，这个复杂对象的各个部分
                        经常面临着剧烈的变化，但是将他们组合在一起的算法却异常稳定
                    将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)
                    Builder模式主要用于分步骤构建一个复杂的对象，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化、
                    变化点在哪里，封装哪里------Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动，其缺点在于难以应对“分步骤构建算法”的需求变动
                    Builder模式中，要注意不同语言中构造器内调用虚函数的差别
对象性能：    
        面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计，但是某些情况下
        面向对象带来的成本必须谨慎处理。
        Singleton：单例模式
            动机：在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保他们的逻辑正确性、以及良好的效率
            保证一个类只有一个实例，并提供一个该实例的全局访问点
            Singleton模式中的实例构造器可以设置为protected以允许子类派生
            Singleton模式一般不要支持拷贝后构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背
            多线程环境下安全的Singleton 要注意对双检查锁的正确实现。
        Flyweight：享元模式
            动机：在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价--主要指内存需求方面的代价
            如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作
            运用共享技术有效地支持大量细粒度的对象。


接口隔离：
        在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题，甚至根本无法实现，采用添加一层间接(稳定)的接口，
        来隔离本来互相紧密关联的接口是一种常见的解决方案。
        Facade:门面模式/界面模式        解耦    系统内和系统外    对象的关联关系
            为子系统中的一组接口提供一个一致(稳定)的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(复用)
            从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种解耦的效果
            内部子系统的任何变化不会影响到Facade接口的变化
            Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次，Facade很多时候更是一种架构设计模式
            Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”,而不是一个简单的功能集合。

        Proxy：代理模式                解耦    两个对象间        的关联关系
            在面向对象系统中，由于某种原因(比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等)直接访问会给使用者、或者系统结构带来很多麻烦
            如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。
            为其他对象提供一种代理以控制(隔离，使用接口)对这个对象的访问。

        Adapter    适配器模式            老接口和新接口
            由于应用环境的变化，常常需要把“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存现象所不满足的。
            将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
            Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”在遗留代码复用。类库迁移等方面非常有用

        Mediator:中介者            解耦    多个对象    
            软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，
            如果遇到一些需求的更改，这种直接的引用关系将面临不断地变化。
            可以使用一个“中介对象”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。
            模式定义：用一个中介者来封装(封装变化)一系列的对象交互。中介者使各对象不需要显示的相互引用(编译时依赖-&gt;运行时依赖)
            从而使其耦合松散(管理变化)，且可以独立地改变它们之间的交互。
            将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为
            “多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。
            随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理
            Facade模式是解耦系统间(单向)的对象关联关系，Mediator模式是解耦系统内各个对象之间(双向)的关联关系
状态变换：
        在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理，同时又维持高层模块的稳定，“状态变化”
        模式为此问题提供解决方案。
        State    状态模式
            允许一个对象在其内部状态改变时改变它的行为，从而使对象看起来似乎修改了其行为。
            State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象
            但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦
            为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的
            即要么彻底转换过来，要么不转换。
            如果State对象没有没有实例对象，那么各个上下文可以共享同一个对象，从而节省对象开销
        Memonto    备忘录模式
            软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。
            如果使用一些共有借口来让其他对象得到对象的状态，便会暴露对象的实现细节。
            如何实现对象状态的良好保存与恢复，但又不会因此破坏对象本身的封装性
            备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态
            Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界(Memento)
            由于现代语言运行时，都具有相当的对象序列化支持，因此往往采用效率高，又较容易正确实现的序列化方案来实现Memento方案
数据结构：
        常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，会破坏组件的复用性，这时候如果将这些特定的数据结构封装在内部
        在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。
        Composite 组合模式
            将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性(稳定)
        采用树形结构来实现普遍存在的对象容器，从而将一对多的关系转为一对一的关系，使得客户代码可以一致地(复用)处理对象和对象容器，
        无需关心处理的是单个的对象还是组合的对象容器
        将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口--而非对象容器的内部实现结构--发生依赖
        从而更能应对变化。
        Composite模式在具体实现中，可以让父对象的子对象反向追溯；如果父对象有频繁的便利需求，可使用缓存技巧来改善效率。

        Iterator  迭代器模式
            集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素，
        同时这种透明遍历也为同一种算法在多种集合对象上进行操作提供了可能。
            提供一种方法，顺序访问一个聚合对象中的各个元素，而又不暴露(稳定)该对象的内部表示
        要点：
            迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示、
            迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作
            迭代器健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题
        Chain of Responsibility 职责链模式
            动机：软件构建过程中，一个请求可能会被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显示指定，将必不可少地带来请求发送者与接受者的紧耦合
            模式定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
            Chain of Responsibility模式应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只能有一个”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”
            的症状，职责链的目的就是将二者解耦，从而更好地应对变化。
            应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性，我们可以在运行时动态添加/修改请求的处理职责。
            如果请求传递到责任链的末尾仍得不到处理，应该有一个合理的缺省机制，这也是每一个接收对象的责任，而不是发出请求的对象的责任。
行为变化：
        在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化，“行为变化”模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。
        Command 命令模式
            软件构建过程中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但是在某些场合--比如需要对行为进行“记录、撤销/重(undo/redo)、事务”等处理，这种无法抵御变化的紧耦合是不合适的
            将请求(行为)封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
            Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象”。
            实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息，通过使用Composite模式，可以将多个“命令”封装为一个“复合命令”MacroCommand。
            Command模式与C++中的函数对象有些类似，但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规范，更严格，但有性能损失，C++函数对象以函数签名来定义行为接口规范，更灵活

        Visitor 访问器模式
            软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为(方法)，如果直接在基类中做这样的改变，将会给子类带来很繁重的变更负担，甚至破坏原有设计
            表示一个作用于某对象结构中的各元素的操作。使得可以在不改变(稳定)各元素的类的前提下定义(扩展)作用于这些元素的新操作(变化)
            Visitor 模式通过所谓双重分发(double dispatch)来实现在不更改(不添加新的操作-编译时)Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作(支持变化)
            所谓双重分发即Visitor模式中间包括了两个多态分发(注意其中的多台机制)：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。
            Visitor模式的最大缺点在于扩展类层次结构(添加新的Element子类)，会导致Visitor类的改变。因此Visitor模式适用于“Element类层次结构稳定，而其中的操作却经常面临频繁改动”


领域问题：    
        软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普遍的编程方式来实现将面临非常频繁的变化。
        在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。
        Interpreter 解析器模式
        给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。
        Interpreter模式的应用场景是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题”才适合使用Interpreter模式。
        使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法。
        Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。        


模式应用时要分辨出哪些是稳定的哪些是变化的。



总结
    一个目标：管理变化，提高复用
    两种手段：分解、抽象
    八大原则：    依赖倒置原则(DIP)
            开放封闭原则(OCP)
            单一职责原则(SRP)
            Liskov替换原则(LSP)
            接口隔离原则(ISP)
            对象组合优于类继承
            封装变化点
            面向接口编程

    重构技法：    静态-&gt;动态
            早绑定-&gt;晚绑定
            继承-&gt;组合
            编译时依赖-&gt;运行时依赖
            紧耦合-&gt;松耦合

    什么时候不用模式：代码可读性很差时
                需求理解还很浅时
                变化没有显现时
                不是系统的关键依赖点
                项目没有复用价值时
                项目将要发布时
    经验之谈：    不要为了模式而模式
            关注抽象类&amp;接口
            理清变化点和稳定点
            审视依赖关系
            要有Framework和Application的区隔思维
            良好的设计是演化的结果</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/" itemprop="url">MySQL逻辑架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T15:22:00+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MySQL逻辑架构图：<br><img src="../../pic/MySQL/MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="MySQL服务器逻辑架构图" title="MySQL服务器逻辑架构图"></p>
<p>第一层的服务并不是MySQL所独有的,大多数基于网络的客户端/服务器的工具或者服务都有类似架构。比如连接处理、授权认证、安全等。<br>第二层架构有MySQL的核心服务功能，包括查询解析、分析、优化、缓存以及所有的内置函数(日期、时间、数学和加密函数)，所有跨存储引擎的功能都在这一层实现：过程、触发器、视图等。<br>第三层包含存储引擎，负责MySQL中数据的存储和提取。</p>
<p>对于SELECT语句，解析查询之前，服务器会先检查查询缓存(Query Cache)</p>
<p>并发控制：<br>在处理并发读或写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题，这两种类型的锁被称为共享锁(shared lock)和排他锁，也称为读锁(read lock)和写锁(write lock)<br>读锁是共享的，互不阻塞的，多个客户在同一时刻可以同时读取同一个资源，互不干扰。<br>写锁是排他的，一个写锁会阻塞其他的写锁和读锁。</p>
<p>锁粒度：<br>因为加锁会消耗资源，故可以通过让锁定对象更有选择性来提高共享资源并发性，尽量只锁定需要修改的部分数据，而不是所有资源，更理想的方式是，只对会修改的数据片进行精确的锁定，只要相互之间不发生冲突，锁定的数据量越少，系统的并发程度越高。</p>
<p>表锁(table lock)：锁定整张表，一个用户在对表进行写操作(插入、删除、更新)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作，只有没有写锁时，其他读取的用户才能获得读锁。</p>
<p>行级锁(row lock)：<br>最大程度支持并发处理，同时锁开销最大，行级锁在存储引擎层实现，而MySQL服务器层没有实现。</p>
<p>事务：<br>一个独立的工作单元，一组原子性的SQL查询。若数据库引擎能成功地对数据库应用该组查询的全部语句，那么就执行该组查询。若其中有任何一条语句无法执行，则所有语句都不执行。<br>ACID<br>A：原子性(atomicity)<br>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。<br>C：一致性(consistency)<br>数据库总是从一个一致性的状态转换到另一个一致性的状态。<br>I：隔离性(isolation)<br>通常来说，一个事务所作修改最终提交之前，对其他事务不可见。<br>D：持久性(durability)<br>一旦事务提交，则其所做的修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</p>
<p>隔离级别：<br>SQL标准中定义了四种隔离级别，规定了一个事务中做的修改，哪些是事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发。</p>
<p>READ UNCOMMITTED(未提交读)<br>事务中的修改即使没有提交，对其他事务都是可见的，被称为脏读(Dirty Read)</p>
<p>READ COMMITTED(提交读)<br>一个事务开始时，只能看见已经提交的事务所做的修改。即一个事务从开始直到提交之前，所做的任何修改对其他事务不可见。也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</p>
<p>REPEATABLE READ(可重复读)【MySQL的默认事务隔离级别】<br>解决脏读问题，保证了同一个事务中多次读同样的记录的结果是一致的。但是无法解决幻读问题<br>幻读：当某个事务在读取某个范围内的记录时另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。</p>
<p>SERIALIZABLE(可串行化)<br>最高级别的隔离，通过强制事务串行执行，避免了幻读问题，但可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用问题。只有在非常需要确保数据一致性且可以接受没有并发的情况下才使用。</p>
<p>死锁：<br>两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p>
<p>解决办法：死锁检查和死锁超时机制，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p>
<p>多版本并发控制(MVCC)：<br>MVCC的实现是通过保存数据在某个时间点的快照来实现的。即不管需要执行多长时间，每个事务看到的数据都是一致的。<br>根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。<br>典型的MVCC的实现有乐观(optimistic)并发控制和悲观(pessimistic)并发控制两种。<br>InnoDB的MVCC通过每行记录后面保存两个隐藏的列来实现，<strong>一个保存了行的创建时间，一个保存了行的过期(删除)</strong>时间。存储的不是实际的时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号就会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>在可重复读[REPEATABLE READ]的情况下，MVCC：<br>SELECT：<br>a.InnoDB只查找版本早于当前事务版本的数据行(行的系统版本号小于或等于事务的系统版本号)。可以确保事务读取的行，要么是在事务开始之前已存在的，要么是事务自身插入或修改过的。<br>b.行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除。<br>符合以上两条的记录才能返回作为查询结果。</p>
<p>INSERT：<br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
<p>DELETE<br>InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
<p>UPDATE<br>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<p>MVCC只在可重复读和提交读两个隔离级别下工作，其他两个隔离级别和MVCC不兼容。<br>[READ UNCOMMITTED]总是读取最新的数据行，而不是符合当前事务版本的数据行<br>[SERIALIZABLE]会对所有读取的行都加锁</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB默认隔离级别是REPEATABLE READ(可重复读),并且通过间隙锁(next-key locking)策略防止幻读的出现。<br>间隙锁是的InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/leetcodeing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/leetcodeing/" itemprop="url">leetcodeing</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T14:11:18+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="leetcode-27-移除元素"><a href="#leetcode-27-移除元素" class="headerlink" title="leetcode-27. 移除元素"></a>leetcode-27. 移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>双指针问题：快指针正常遍历数组，慢指针只有遇到不等于val的值时才自增，当遍历数组结束后慢指针的值为数组中不为val的元素个数，即移除后数组的新长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(nums == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">    			nums[flag] = nums[i];</span><br><span class="line">    			flag++;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">			<span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="leetcode-33搜索旋转排序数组"><a href="#leetcode-33搜索旋转排序数组" class="headerlink" title="leetcode-33搜索旋转排序数组"></a>leetcode-33搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2])。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是O(logn) 级别。</p>
<p>看到时间复杂度O(logn)即可知道要使用二分法了。<br>旋转数组数据状况分析：一个升序数组结果旋转之后，变为两个升序数组，其中，右边升序数组的最大值小于左边升序数组的最小值。会因为旋转位置和mid之间的不同而导致不同的数据状况<br>例如：[0,1,2,4,5,6,7,8,9] 可能变为<br>情况A：[4,5,6,7,8,9,0,1,2] 此时left &lt; mid,mid左端是排序数组，mid右端是旋转数组<br>也可能变为<br>情况B：[7,8,9,0,1,2,3,4,5,6] left &gt; mid,此时mid左端是旋转数组，右端是排序数组</p>
<p>若target = mid则直接返回<br>否则分情况讨论<br>情况A时,若mid &lt; target ,则target必在mid右端的旋转数组中，因为那里才有大于mid的数字<br>若mid &gt; target , 则需要继续判断,left与target之间的关系</p>
<p>当left &lt; target,target在mid左端,[因为右端有序部分的最大值也小于left值]<br>当left &gt; target,target在mid右端,[因为左端部分最小值都大于target,必须在右端找]</p>
<p>情况B时, 若mid &gt; target,则target必在mid左端的旋转数组中，<br>若mid &lt; target,则需要继续判断,right与target之间的关系</p>
<p>当right &gt; target,target在mid右端<br>当right &lt; target,target在mid左端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">search</span> <span class="params">(<span class="keyword">int</span> []nums , <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(nums[left]==target)<span class="keyword">return</span> left;</span><br><span class="line">		<span class="keyword">if</span>(nums[right]==target)<span class="keyword">return</span> right;</span><br><span class="line">		<span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">			<span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(nums[left]&lt;nums[mid])&#123;</span><br><span class="line">				<span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">					left = mid;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&lt;target)&#123;</span><br><span class="line">					right = mid;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					left = mid;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">				right = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]&gt;target)&#123;</span><br><span class="line">				left = mid;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				right = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15. 三数之和"></a>leetcode 15. 三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<p>此类题目一定要先排序，排序后，固定a，让b、c当做双指针滑动的找符合条件的点，因为不可包含重复三元组，所以要对a、b、c分别做去重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">return</span> res;<span class="comment">//特殊情况的返回值，此时数组过短直接返回。</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//从小到大排列的数组，若最左端的数字已大于0则其右边也都为正数，和必不为0</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//对a去重</span></span><br><span class="line">            <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i]+nums[L]+nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    List&lt;Integer&gt;cur = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                    cur.add(nums[i]);</span><br><span class="line">                    cur.add(nums[L]);</span><br><span class="line">                    cur.add(nums[R]);</span><br><span class="line">                    res.add(cur);</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;<span class="comment">//对b去重</span></span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;<span class="comment">//对c去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                    <span class="comment">//若找到一个为0的三元组，则b、c的两端同时移动，不为0时则如下方法移动。</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-16-最接近的三数之和"><a href="#leetcode-16-最接近的三数之和" class="headerlink" title="leetcode 16. 最接近的三数之和"></a>leetcode 16. 最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>和上一题一样，排序后固定一端再用双指针，省了去重操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i]+nums[L]+nums[R];</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(sum-target)&lt;Math.abs(res-target))</span><br><span class="line">                res = sum;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">                L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)</span><br><span class="line">                R--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum==target)</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode18-四数之和"><a href="#leetcode18-四数之和" class="headerlink" title="leetcode18. 四数之和"></a>leetcode18. 四数之和</h2><p>给定一个包含n个整数的数组nums和一个目标值target,判断nums中是否存在四个元素a,b,c和d,使得a+b+c+d的值与target相等？找出所有满足条件且不重复的四元组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len &lt; <span class="number">4</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - <span class="number">3</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min = nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(min&gt;target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> max = nums[i]+nums[len-<span class="number">1</span>]+nums[len-<span class="number">2</span>]+nums[len-<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; len-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;(nums[j]==nums[j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> l = len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> min2 = nums[i]+nums[j]+nums[k]+nums[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(min2&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> max2 = nums[i]+nums[j]+nums[l]+nums[l-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(max2&lt;target)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(k&lt;l)&#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = nums[i]+nums[j]+nums[k]+nums[l];</span><br><span class="line">                    <span class="keyword">if</span>(cur==target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));</span><br><span class="line">                        k++;</span><br><span class="line">                        <span class="keyword">while</span>(k&lt;l&amp;&amp;nums[k]==nums[k-<span class="number">1</span>])&#123;</span><br><span class="line">                            k++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        l--;</span><br><span class="line">                        <span class="keyword">while</span>(k&lt;l&amp;&amp;nums[l]==nums[l+<span class="number">1</span>])&#123;</span><br><span class="line">                            l--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur&gt;target)&#123;</span><br><span class="line">                        l--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">leetcode <span class="number">13</span>. 罗马数字转整数</span><br><span class="line">-------------</span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 <span class="number">4</span> 不写做 IIII，而是 IV。数字 <span class="number">1</span> 在数字 <span class="number">5</span> 的左边，所表示的数等于大数 <span class="number">5</span> 减小数 <span class="number">1</span> 得到的数值 <span class="number">4</span> 。同样地，数字 <span class="number">9</span> 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line">I 可以放在 V (<span class="number">5</span>) 和 X (<span class="number">10</span>) 的左边，来表示 <span class="number">4</span> 和 <span class="number">9</span>。</span><br><span class="line">X 可以放在 L (<span class="number">50</span>) 和 C (<span class="number">100</span>) 的左边，来表示 <span class="number">40</span> 和 <span class="number">90</span>。 </span><br><span class="line">C 可以放在 D (<span class="number">500</span>) 和 M (<span class="number">1000</span>) 的左边，来表示 <span class="number">400</span> 和 <span class="number">900</span>。</span><br><span class="line">由题意可知，一个小数字出现在一个大数字的左边，则该小数字相当于一个负数，其余数字累加即可。</span><br><span class="line">遍历字符串，遇到任何一个比他下一个数字小的数字，将其视为负数，否则视为正数，遍历过程中累加，要注意，因为是双指针一起遍历，所以遍历完一遍后，还剩最后一个数字没加上。</span><br><span class="line">```Java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">int</span> right = getValue(s.charAt(i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                res -= left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res += left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += getValue(s.charAt(len-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="leetcode-14-最长公共前缀"><a href="#leetcode-14-最长公共前缀" class="headerlink" title="leetcode 14. 最长公共前缀"></a>leetcode 14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br>遍历字符串数组，用ans保存第一个字符串和第二个字符串的公共前缀，再依次求ans和后面字符串的公共前缀并更新ans，若ans已为空则可直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span>(ans.equals(<span class="string">""</span>))</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="leetcode17-电话号码的字母组合"><a href="#leetcode17-电话号码的字母组合" class="headerlink" title="leetcode17. 电话号码的字母组合"></a>leetcode17. 电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br>根据输入的数字串递归，每次处理完一个数字后将剩余的数字串送入递归函数中。处理完所有数字后压入结果。<br>因为是在处理字符串。字符串中的每个字符都要在加入之后做递归，故要在循环的过程中递归。<br>定义递归函数<br>iterStr(String str , String letter , int index)<br>str是输入的数字串，根据index来判断取到哪里了。<br>letter是当前的字符结果。<br>当index的值等于str 的长度时，代表letter里已经存了数字串中的某一种结果可以返回。<br>其他情况下，先在letter上加入一个字母，再使得index+1来取数字串中的下一个数字。<br>letter上加入的字母，是先按照数字再letter_map中找到对应的字符串，再根据字符串长度做循环，依次加入字符串上的每一个字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String []letter_map = <span class="keyword">new</span> String[]&#123;<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        iter(digits,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iter</span><span class="params">(String str , String letter , <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == str.length())&#123;</span><br><span class="line">            res.add(letter);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        String next = letter_map[str.charAt(index)-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next.length();i++)&#123;</span><br><span class="line">            iter(str , letter+next.charAt(i),index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="leetcode22-括号生成"><a href="#leetcode22-括号生成" class="headerlink" title="leetcode22. 括号生成"></a>leetcode22. 括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>n对括号，左右各有n个，一个有效的括号组合要求任意时刻左括号数量都要大于右括号数量。<br>令left为还剩余的左括号数量，right为还剩余的右括号数量，则需要保证，任意时刻剩余的左括号都比剩余的右括号多。即 left&gt;right;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(<span class="string">""</span>,n,n,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String curStr , <span class="keyword">int</span> left , <span class="keyword">int</span> right , List&lt;String&gt;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(curStr+<span class="string">"("</span>,left-<span class="number">1</span>,right,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(curStr+<span class="string">")"</span>,left,right-<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode24-两两交换链表中的节点"><a href="#leetcode24-两两交换链表中的节点" class="headerlink" title="leetcode24. 两两交换链表中的节点"></a>leetcode24. 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>交换节点时不要断链，待交换节点为A-&gt;B，交换后变为 B-&gt;A。<br>每组交换过程用到<br>temp、A、B三个节点。<br>temp是交换组的前置。<br>A、B先各自就位。<br>交换后B是交换组中第一个节点，先让temp指向B(temp.next=B)，维持链条完整;<br>再进行A、B的交换(A.next = B.next , B.next = A);<br>再令temp等于交换组的第二个节点，作为下一个交换组的前置。</p>
<p>声明一个虚假的头节点，来处理链表中只有一个节点的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        ListNode temp = pre;</span><br><span class="line">        <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>&amp;&amp; temp.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode A = temp.next;</span><br><span class="line">            ListNode B = temp.next.next;</span><br><span class="line">            temp.next = B;</span><br><span class="line">            A.next = B.next;</span><br><span class="line">            B.next = A;</span><br><span class="line">            temp = A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/12/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/12/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" itemprop="url">论文笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-12T12:00:59+08:00">
                2020-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="U-net与Dense-net相结合的视网膜血管提取"><a href="#U-net与Dense-net相结合的视网膜血管提取" class="headerlink" title="U-net与Dense-net相结合的视网膜血管提取"></a>U-net与Dense-net相结合的视网膜血管提取</h2><p>创新部分：<br>1、U-net层次化对称结构和Dense-net稠密连接方式的结合<br>2、白话预处理奇数弱化原始彩色眼底图像中的亮度不均，增强图像中血管区域的对比度<br>3、数据集随即旋转 Gamma变化实现数据增广<br>4、将每幅图像随机分割成若干较小的图块，用于减小模型参数规模，降低训练难度</p>
<h2 id="采用卷积核金字塔和空洞卷积的单阶段目标检测"><a href="#采用卷积核金字塔和空洞卷积的单阶段目标检测" class="headerlink" title="采用卷积核金字塔和空洞卷积的单阶段目标检测"></a>采用卷积核金字塔和空洞卷积的单阶段目标检测</h2><p>创新部分：<br>1、采用多种方式融合特征信息，先使用逐像素相加方式融合多层不同大小的特征图信息，然后在通道维度拼接不同阶段的特征图。<br>2、在模型的锚框机制中引入卷积核金字塔结构以解决多尺度问题<br>3、采用空洞卷积减少大尺度卷积核增加的参数量，合理降低锚框数量。</p>
<p>目标检测分为两类，一类是无特征信息融合的例如 FastR-CNN 和Faster R-CNN 以及YOLOv1、YOLOv2<br>一类是有特征信息融合，在多个特征图上进行预测如SSD、MS-CNN(multi-scale CNN)或在单个融合的特征图上进行预测HyperNet和ION(inside-outsidenot)使用拼接方式融合不同层次的特征。或在多个融合的特征图上进行预测如DSSD(deconvolutional single-shot detector)使用逐像素相乘的方式融合信息。YOLOv3、FPN、MaskR-CNN使用逐像素相加的方式融合信息。</p>
<p>为利用不同深度特征图的优势，本文在两个阶段上融合特征信息。<br>1、在<strong><em>特征提取网络之后</em></strong>添加多个卷积层，对添加的多个卷积层使用<strong><em>逐像素相加</em></strong>的方式从深层到浅层逐层融合特征信息，形成具有丰富语义信息和细节信息的特征图。<br>2、为进一步增强特征信息融合，使用<strong><em>通道拼接的方式</em></strong>为上一步得到的融合特征图<strong><em>拼接不同阶段的特征图</em></strong>，形成语义、细节信息更加丰富的特征图。<br>特征信息融合模块：从原始SSD预测层的最深层开始，先通过双线性插值操作增大特征图的分辨率，再使用逐像素相加的方式和前一层特征图融合，直至原始SSD预测层的最浅层。再拼接不同阶段的特征图。</p>
<h2 id="多尺度特征融合工件目标语义分割"><a href="#多尺度特征融合工件目标语义分割" class="headerlink" title="多尺度特征融合工件目标语义分割"></a>多尺度特征融合工件目标语义分割</h2><p>创新部分：在ResNet网络的第四个block层后继续多尺度特征提取。而图像金字塔只是简单地进图像分辨率的变化，虽然能获得多尺度信息表达，但ResNet网络的第四个block层的输出已经是一个维度很小的特征图，若继续降分辨率，不利于后续的特征响应，反而会增加网络模型参数计算量，因此使用空洞卷积代替降分辨率操作，在不降低分辨率的前提下，有效增大了滤波器的感受野，又充分获得了上级图像的局部特征信息。<br>故采用三层图像金字塔模式，底层为block4层输出的特征图，中层为使用不同采样率的多个并行空洞卷积，以提取不同尺度的局部特征信息，顶层为中层提取的局部特征信息的融合层。</p>
<h2 id="多尺度特征图融合的目标检测"><a href="#多尺度特征图融合的目标检测" class="headerlink" title="多尺度特征图融合的目标检测"></a>多尺度特征图融合的目标检测</h2><p>创新部分：利用原始SSD网络提取特征图，通过1 * 1卷积层将提取的特征图统一为256维，通过反卷积操作增加自顶向下特征图的空间分辨率，通过对应元素相加的操作，将两个方向的特征图进行融合，融合后的特征图采用3 * 3的卷积核进行卷积操作，减小特征图融合后的混叠效应。<br>以完全卷积的方式处理任意的单尺度图像，然后特征融合结构将特征提取网络的<strong><em>原始特征图</em></strong>和<strong><em>反卷积后的特征图</em></strong>进行融合操作。</p>
<h2 id="多模态深度神经网络的固废对象分割"><a href="#多模态深度神经网络的固废对象分割" class="headerlink" title="多模态深度神经网络的固废对象分割"></a>多模态深度神经网络的固废对象分割</h2><p>在颜色退化严重的场景下，把RGB图像和深度图一起作为深度卷积神经网络的输入，<br>创新部分：<br>1、在VGG16网络结构的基础上融合深度信息，把VGG16最后的全连接层改造成3层卷积层，形成一个全卷积网络，进行多模态信息的特征学习。<br>深度神卷积经网络包含2个输入层data1和data2，data1输入RGB图像和对应的标签文件，data2输入对应的深度图。将两者最后一层卷积层输出的特征图进行加权求和后作为输入训练softmax分类器。<br>网络结构改进：<br>1、修改输入，增加一个并列分支data2层用于训练对应深度图<br>2、避免特征图空间分辨率下降，普通池化会缩小图片尺寸，损失精细结构信息，令第四第五个池化层步长为1，再加上1填充，池化核尺寸都为3，这样经过池化后特征图大小不变，由于步长比池化核的尺寸小，输出之间会有重叠和覆盖，提高了特征丰富性，但后层感受野发生了变化，为使感受野不变，后面的卷积层使用空洞卷积，以在不增加参数的前提下，增加感受野。<br>3、修改卷积层滤波器核数，由于进行学习的图片场景较为复杂，包含的信息、特征数相对较多，需要更高维度上的特征学习，全连接层改造的三层卷积核的绿薄荷为1024、1024、4（4为最终的输出数）.</p>
<h2 id="多特征融合的文档图像版面分析"><a href="#多特征融合的文档图像版面分析" class="headerlink" title="多特征融合的文档图像版面分析"></a>多特征融合的文档图像版面分析</h2><p>采用不同大小的卷积核并行对输入图像进行特征提取，接着将卷积后的特征图进行融合，组成特征融合模块，然后选取DeepLabV3中的串并行空间金字塔策略。并添加图像级特征对提取的特征图进一步优化，最后通过双线性插值法对图像进行恢复。</p>
<p>DeepLabV3的核心部分，串并行空间金字塔池化模块(ASPP)<br>通过不同感受野的空洞卷积核对特征图进行上采样，捕获多尺度信息，分别为1 * 1以及扩张率为6、12、18的3 * 3空洞卷积核。<br>采样卷积核大小接近特征图大小时，3 * 3的卷积核失去捕捉全图像的信息，退化为1 * 1的卷积核，可以采用平均池化特征图进行处理经过卷积，再融合得出的特征图。最终将经过4种不同卷积核得到的特征图与图像及特征进行融合。</p>
<h2 id="改进SSD算法在零部件检测中的应用研究"><a href="#改进SSD算法在零部件检测中的应用研究" class="headerlink" title="改进SSD算法在零部件检测中的应用研究"></a>改进SSD算法在零部件检测中的应用研究</h2><p>改进：<br>1、修改backbone为MobileNetV3-Large，移除平均池化层和最后的1 * 1卷积层，<br>2、减小输入图像的尺寸，提高检测速度，变300 * 300为224 * 224<br>3、用特征金字塔网络提高对较小零件检测效果，选取对应尺寸(28,28)(14,14)(7,7)(4,4)(2,2)(1,1)的所有特征层和最后一层组成自底向上的特征金字塔结构。</p>
<h2 id="改进的YOLOv3红外视频图像行人检测算法"><a href="#改进的YOLOv3红外视频图像行人检测算法" class="headerlink" title="改进的YOLOv3红外视频图像行人检测算法"></a>改进的YOLOv3红外视频图像行人检测算法</h2><p>改进：<br>1、对红外图像数据集的目标候选框进行维度聚类选择最优anchor个数，YOLOv3的anchor个数和维度是有VOC20类和COCO80类数据集聚类得到，不适用于红外行人检测，红外行人检测时，行人在图片中的长宽比始终是一个相对固定的值。<br>2、调整分类网络预训练过程，使用不同分辨率的红外图像作为网络输入，用VOC数据集进行模型的预训练。使用不同分辨率的红外图像作为分类数据集，可以取得比较明显的微调效果。<br>3、网络地铁带过程中，随机改变输入图像的尺寸，进行多尺度网络训练，使模型对不同尺寸图像的检测具有鲁棒性</p>
<h2 id="改进的YOLOv3算法及其在小目标检测中的应用"><a href="#改进的YOLOv3算法及其在小目标检测中的应用" class="headerlink" title="改进的YOLOv3算法及其在小目标检测中的应用"></a>改进的YOLOv3算法及其在小目标检测中的应用</h2><p>改进：YOLOv3网络利用8倍降采样输出的特征图对小目标进行检测，这意味着当目标小于8×8时网络对目标的预测会出现困难，并且特征图为8倍降采样的目标检测层对小目标位置信息的检测能力是有限的。为了使网络获取更多小目标的特征信息，提高对小目标的检测率。<br>利用原网络中输出的4倍降采样特征图对目标进行检测，对YOLOv3输出的8倍降采样特征图进行2倍上采样，将2倍上采用特征图与Darknet53中第2个残差块输出的4倍降采样特征图进行拼接，建立输出为4倍降采样的特征融合目标检测层以检测小目标。为了获得更多低层的小目标位置信息，在源网络的第2个残差块中增加2个残差单元。</p>
<h2 id="基于YOLOV3的复杂环境红外弱小目标检测"><a href="#基于YOLOV3的复杂环境红外弱小目标检测" class="headerlink" title="基于YOLOV3的复杂环境红外弱小目标检测"></a>基于YOLOV3的复杂环境红外弱小目标检测</h2><p>红外图像特点：<br>信噪比较低，几何轮廓较为模糊，且与真实形态可能存在较大差异，对其成像特征进行分析，可以提升检测网络对目标的适配能力。</p>
<p>改进:无，0-0醉了，可能是因为发在航空兵器</p>
<h2 id="改进的YOLOv3网络在钢板表面缺陷检测研究"><a href="#改进的YOLOv3网络在钢板表面缺陷检测研究" class="headerlink" title="改进的YOLOv3网络在钢板表面缺陷检测研究"></a>改进的YOLOv3网络在钢板表面缺陷检测研究</h2><p>1、使用轻量级网络MobileNet来代替YOLOv3原有网络中的密集连接Darknet-53，适当的减少参数量的提取<br>2、加入空洞卷积，提高网络对小目标缺陷的检测能力，<br>3、在网络结构的最后一层卷积中加入Inception结构。</p>
<h2 id="基于YOLOv3的红外行人小目标检测技术研究"><a href="#基于YOLOv3的红外行人小目标检测技术研究" class="headerlink" title="基于YOLOv3的红外行人小目标检测技术研究"></a>基于YOLOv3的红外行人小目标检测技术研究</h2><p>借鉴SENet中对特征进行权重重标定的思路，将SE block引入YOLOv3中，提升了网络的特征描述能力。<br>根据SENet的思路，对网络进行改进一般有几种方式<br>1、直接在卷积层后面直接加SENet模块，对所有网络都通用，但是由于现在的网络中都含有大量的卷积层且参数量巨大，且需要大量实验来确定哪些卷积层后面加入新模块。<br>2用加入的SENet的模块替换原有网络中的inception或者residual层，这类替换位置较为明确，在YOLOv3中含有较多的Residual层，于是对网络的改进采取引入SE-Resnet模块的方法。</p>
<h2 id="基于多尺度特征融合的小目标行人检测"><a href="#基于多尺度特征融合的小目标行人检测" class="headerlink" title="基于多尺度特征融合的小目标行人检测"></a>基于多尺度特征融合的小目标行人检测</h2><p>针对SSD当前存在的小目标漏检及误检问题，结合反卷积与特征融合思想，提出回归SSD模型，将原SSD特征层反卷积后与较浅层特征结合，实现复杂场景下小目标行人检测。</p>
<h2 id="基于改进Fast-R-CNN的红外图像行人检测研究"><a href="#基于改进Fast-R-CNN的红外图像行人检测研究" class="headerlink" title="基于改进Fast R-CNN的红外图像行人检测研究"></a>基于改进Fast R-CNN的红外图像行人检测研究</h2><p>改进：<br>1、结合红外图像的特点，提出了一种自适应ROI提取算法，在不影响准确率的前提下降低了ROI数量，使得网络的计算量减小。<br>Fast R-CNN用selective search算法在一帧图片中生成约2000个候选框，计算量较大，红外图像不含色彩，对于一帧红外光图片，背景和行人的灰度差值十分明显，先通过图像的局部均值、标准差对局部区域做粗检测，<br>2、提出了一种加权锚点框的定位机制，基于3种不同宽高比锚点框的检测置信度进行坐标加权，获得更准确的定位框。</p>
<h2 id="基于红外热成像与YOLOv3的夜间目标识别方法"><a href="#基于红外热成像与YOLOv3的夜间目标识别方法" class="headerlink" title="基于红外热成像与YOLOv3的夜间目标识别方法"></a>基于红外热成像与YOLOv3的夜间目标识别方法</h2><p>图像预处理，提高图像对比度，增强图像细节，去除图像噪声。<br>提高图像对比度目的在于突出热源与背景的反差，突出热源目标，采用高反差保留法，该方法主要是将图像中颜色、明暗反差较大两部分的交界处保留下来。表达形式如下：<br>dst = img - R * Blur(img)<br>dst为处理后结果，img为原始图像，R为增益参数：Blur为调用的高斯滤波器。<br>R的取值不同对对比度的提升不同，R取0位原始图像，R取1提高对比度不强，R取6时对比度过高产生早点，因此本文R值取3。<br>增强对比度后，使用高斯高通滤波器对图像进行锐化，在增强边沿、细节的同时，不会丢失源图像的低频成分。<br>图像锐化在增强热成像图像细节特征的同时会引入随机噪声点，因此图像与处理最后一步进行降噪工作，使用高斯低通滤波器平滑，降低图像中的噪点。</p>
<h2 id="基于显著图融合的无人机载热红外图像目标检测方法。、"><a href="#基于显著图融合的无人机载热红外图像目标检测方法。、" class="headerlink" title="基于显著图融合的无人机载热红外图像目标检测方法。、"></a>基于显著图融合的无人机载热红外图像目标检测方法。、</h2><p>热红外图片对比度低，纹理特征弱，本文使用热红外图像的显著图来进行图像增强，作为目标检测器的注意力机制。<br>使用BASNet生成显著图，通过通道替换和像素级加权融合两种方案将红外热图像与对应的显著图进行融合增强。<br>融合方案：<br>1、用显著图分别替换R、G、B三个通道中的一个，每个替换方式都对应于一个新的融合图像，目标检测性能存在差异。<br>2、将显著图与热红外图像的三个通道亮度值分别在像素级别上直接按各自0.5的权重比例融合，显著图与热红外图像的融合在突出图像中行人及车辆目标的同时保留了图像中的纹理信息。<br>将MobileNetv2的平均池化和最后一个卷积层去掉，使其替换YOLOv3网络中原有的DarkNet53网络，同时分别将分辨率为输入图像8倍和16倍下采样的特征层中的最后一层作为细粒度特征与检测网络中上采样之后的高级语义特征融合。增强目标检测能力，对无人机航拍图像中的小目标检测有重要意义。</p>
<h2 id="结合改进Deeplab-V3-网络的水岸线检测方法"><a href="#结合改进Deeplab-V3-网络的水岸线检测方法" class="headerlink" title="结合改进Deeplab V3+网络的水岸线检测方法"></a>结合改进Deeplab V3+网络的水岸线检测方法</h2><p>利用伽马函数扩充样本<br>修改deeplab v3+网络，对xception结构进行微调，同时在decoder时增加一路低级特征，增加特征信息然后利用图像信息设定损失权重系数。</p>
<h2 id="融合多层特征的多尺度行人检测"><a href="#融合多层特征的多尺度行人检测" class="headerlink" title="融合多层特征的多尺度行人检测"></a>融合多层特征的多尺度行人检测</h2><p>针对行人检测问题，删除深度残差网络的一部分，仅采用深度残差网络的3个区域提取特征图，然后采用最邻近上采样法将最后一层提取的特征图放大两倍后再用相加法，将高层语义信息丰富的特征和低层细节信息丰富的特征进行融合。</p>
<h2 id="针对小目标的深度学习行人检测算法研究"><a href="#针对小目标的深度学习行人检测算法研究" class="headerlink" title="针对小目标的深度学习行人检测算法研究"></a>针对小目标的深度学习行人检测算法研究</h2><p>SSD 算法采用多尺度检测框架来检测不同大小的目标行人，存在两个主要的问题<br>1、多尺度检测框架中各个特征层之间的关联不够密切，特征层之间的上下文信息没有被充分利用<br>2、SSD算法主要采用浅层网络的Conv4_3层来检测小目标行人，而Conv4_3层属于低级特征，语义区分性不强，存在行人特征提取不够充分的问题。</p>
<h2 id="基于YOLO的实时目标检测方法研究"><a href="#基于YOLO的实时目标检测方法研究" class="headerlink" title="基于YOLO的实时目标检测方法研究"></a>基于YOLO的实时目标检测方法研究</h2><p>YOLO-PC(YOLO based People Counting Approach)<br>将YOLO对图像的划分从7×7变为9×9，同时对每个划分的网格增加了检测的数量，多划分的改进有效增加了对行人检测的平均置信度，并且获得了更多的行人检测框基于边界选择的方法对特定区域统计行人人流量，可以避免对非目标区域行人的检测和计数。<br>实现YOLO-PC增加了参数，为减少参数数量，基于YOLO-PC提出了模型压缩的实时行人计数算大。<br>基本实现了模型的无损精度压缩。<br>Squeezenet提出了一种新的卷积计算模块火层模块。<br>引入并优化火层模块，并利用其替换了具有较大参数量的卷积层来减少参数。</p>
<p>Squeezenet采用1×1的卷积核代替3×3的卷积核用来构建非常紧凑的神经网络。参数数量减少50倍</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/" itemprop="url">排序算法的复杂度稳定性分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T13:04:15+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">排序算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/" itemprop="url">基数排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T13:04:00+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">排序算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从低位到高位逐渐对数字进行排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E6%A1%B6%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E6%A1%B6%E6%8E%92%E5%BA%8F/" itemprop="url">桶排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T13:03:37+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">排序算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>桶排序可看做计数排序的升级版，将数据分到有限的桶里，每个桶再分别排序。<br>先设定一个定量的数组当做空桶，遍历数据，将数据放入一个个对应的桶中，对每个不是空的桶进行排序，并从不是空的桶里把排好序的数据拼接起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line">			max = Math.max(max, arr[i]);</span><br><span class="line">			min = Math.min(min, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> bucketNum = (max - min)/arr.length+<span class="number">1</span>;</span><br><span class="line">		ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketNum; i++) &#123;</span><br><span class="line">			bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> num = (arr[i] - min) / arr.length;</span><br><span class="line">			bucketArr.get(num).add(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bucketArr.size();i++) &#123;</span><br><span class="line">			Collections.sort(bucketArr.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(bucketArr.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/" itemprop="url">计数排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T13:03:22+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">排序算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>计数排序不是基于比较的排序算法,是桶排序思想中的一种，可看做每个桶的大小为1。需要额外开辟空间,空间复杂度O(n+k),时间复杂度O(n+k)，待排序的数据值存储在额外开辟的数组空间中，计数排序要求数据必须是有确定范围的整数，常用于数量大但是范围小的排序，例如人员年龄排序，高考名次排名。<br>1、先找出待排序数组中最大和最小的元素。<br>2、统计数组中每个值为i的元素出现的次数，存入数组的第i项.<br>3、将数组中的每个元素按顺序放入新数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]&gt;max) &#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]&lt;min) &#123;</span><br><span class="line">				min = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> l = max - min;</span><br><span class="line">		<span class="keyword">int</span> []countarr = <span class="keyword">new</span> <span class="keyword">int</span> [l+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">			countarr[arr[i]-min]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; countarr.length;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(countarr[i]-- &gt;<span class="number">0</span>) &#123;</span><br><span class="line">				arr[index++] = i+min;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">			System.out.print(a+<span class="string">" "</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E5%A0%86%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E5%A0%86%E6%8E%92%E5%BA%8F/" itemprop="url">堆排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T13:03:00+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">排序算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>堆是一种完全二叉树，且满足父节点大于孩子结点<br>完全二叉树：节点顺序满足从上往下，从左往右。<br>堆排序过程：<br>1、先构造一个大顶堆，取堆顶数字(即最大值)<br>2、将剩下的数字构建一个大顶堆，取堆顶数字(即剩下值中的最大值)<br>3、重复以上操作，直到取完堆中的数字，得到一个从大到小排列的序列。</p>
<h2 id="堆的构建过程-heapify"><a href="#堆的构建过程-heapify" class="headerlink" title="堆的构建过程(heapify)"></a>堆的构建过程(heapify)</h2><p>从下往上的去构建堆，先在最底层的节点中，找出父节点与两个子节点中的最大值，和父节点做交换。<br>用数组去表示一棵完全二叉树，按层序，从上至下，从左往右的表示。则可知<br>对于i节点，其<br>父节点parent = (i-1)/2<br>左孩子c1 = 2 * i+1<br>右孩子c2 = 2 * i+2<br>当一个大顶堆的根结点发生变化时，通过heapfiy操作来将其重新变为大顶堆。<br>而想要把一个乱序的数组变为大顶堆，build需要从底往上的进行heapfiy操作。即从最后一个结点的parent节点开始，到根节点为止不断地heapify。<br>想要把已经构建好的大顶堆变成有序数组，需要把堆顶元素和末尾元素交换，再令堆的大小自减1，并继续做heapfiy操作，直到整个数组交换完毕为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		heap_sort(arr, len);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a:arr) &#123;</span><br><span class="line">			System.out.print(a+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		build(arr, n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			swap(arr, i, <span class="number">0</span>);</span><br><span class="line">			heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> last = n-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> parent = (last-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = parent ; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">			heapify(arr, n , i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> []arr ,<span class="keyword">int</span> n, <span class="keyword">int</span>  i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c1 = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> c2 = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> max = i;</span><br><span class="line">		<span class="keyword">if</span>(c1&lt;n &amp;&amp; arr[c1]&gt;arr[max]) &#123;</span><br><span class="line">			max = c1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(c2&lt;n &amp;&amp; arr[c2]&gt;arr[max]) &#123;</span><br><span class="line">			max = c2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i!=max) &#123;</span><br><span class="line">			swap(arr, max, i);</span><br><span class="line">			heapify(arr, n, max);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">莫一兮</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">莫一兮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
