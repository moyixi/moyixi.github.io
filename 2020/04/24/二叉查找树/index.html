<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>二叉查找树 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="二叉查找树(BST)：根结点大于等于左子树所有节点，小于等于右子树所有节点.特点：中序遍历有序(由小到大)，那么按右 中 左 方式的遍历即由大到小的有序 1、修建二叉查找树给定一个二叉查找树和左右边界值，修剪二叉查找树，只保留边界值之内的数字。 public TreeNode trimBST(TreeNode root , int L ,int R){     if(root == null) r">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉查找树">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="二叉查找树(BST)：根结点大于等于左子树所有节点，小于等于右子树所有节点.特点：中序遍历有序(由小到大)，那么按右 中 左 方式的遍历即由大到小的有序 1、修建二叉查找树给定一个二叉查找树和左右边界值，修剪二叉查找树，只保留边界值之内的数字。 public TreeNode trimBST(TreeNode root , int L ,int R){     if(root == null) r">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-04-26T05:07:32.106Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-二叉查找树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" class="article-date">
  <time datetime="2020-04-24T06:38:09.331Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      二叉查找树
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>二叉查找树(BST)：根结点大于等于左子树所有节点，小于等于右子树所有节点.<br>特点：中序遍历有序(由小到大)，那么按右 中 左 方式的遍历即由大到小的有序</p>
<h2 id="1、修建二叉查找树"><a href="#1、修建二叉查找树" class="headerlink" title="1、修建二叉查找树"></a>1、修建二叉查找树</h2><p>给定一个二叉查找树和左右边界值，修剪二叉查找树，只保留边界值之内的数字。</p>
<pre><code>public TreeNode trimBST(TreeNode root , int L ,int R){
    if(root == null) return null;
    if(root.val &lt; L) return trimBST(root.right,L,R);
    //若当前root值小于左边界，则左子树可被抛弃，问题等同于修剪以root.right为根结点的子树
    if(root.val &gt; R) return trimBST(root.left,L,R);
    //若当前root值大于右边界，则右子树可被抛弃，问题等同于修剪以root.left为根结点的子树
    root.left = trimBST(root.left,L,R);
    root.right = trimBST(root.right,L,R);
    //经过上面两部判断后，root值都在L,R的范围之内，可将问题递归至左右结点。
    return root;
}</code></pre><h2 id="2-0、寻找二叉查找树由小到大第k个元素"><a href="#2-0、寻找二叉查找树由小到大第k个元素" class="headerlink" title="2.0、寻找二叉查找树由小到大第k个元素"></a>2.0、寻找二叉查找树由小到大第k个元素</h2><p>因为二叉查找树中序遍历有序，所以中序遍历到第k个即可</p>
<pre><code>private int cnt = 0;
private int val;
public int kthSmallest(TreeNode root , int k){
    inOrder(root, k);
    return val;
}
//类比于普通情况下的中序遍历
void dfs(TreeNode root){
    dfs(root.left);
    visit(root);
    dfs(root.right);
}
private void inOrder(TreeNode node,int k){//中序遍历找到第k个元素的过程
    if(node == null) return ;
    inOrder(node.left,k);
//
    cnt++;
    if(cnt == k){
        val = node.val;
        return;
    }
    //上面这一坨就是visit(root);讲的故事
//
    inOrder(node.right,k);
}</code></pre><h2 id="2-1、寻找二叉查找树由小到大第k个元素-递归解法"><a href="#2-1、寻找二叉查找树由小到大第k个元素-递归解法" class="headerlink" title="2.1、寻找二叉查找树由小到大第k个元素,递归解法"></a>2.1、寻找二叉查找树由小到大第k个元素,递归解法</h2><pre><code>// count 函数计算以root为根节点的二叉树上有多少个节点。
public int count(TreeNode root){
    if(root == null) return 0;
    return 1 + count(root.left)+count(root.right);
}
//若以root.left 为根节点的二叉树上有n个结点则 root 是第 n+1个节点。
//那么进入此题判断逻辑，若 root.left 有k-1个节点，则root为所求的第k个节点。
//若root.left上的节点比k-1多，则抛弃右子树
//若root.left上的节点比k-1少，则抛弃左子树，并减去左子树上的节点个数和root节点，在右子树上继续进行本题。
public int kthSmallest(TreeNode root , int k){
    int leftcount = count(root.left);
    if(leftcount == k - 1) return root.val;
    if(leftcount  &gt; k - 1) return kthSmallest(root.left , k);
    return kthSmallset(root.right , k - leftcount - 1);
}</code></pre><h2 id="3、把二叉查找树每个节点的值都加上比它大的节点的值。"><a href="#3、把二叉查找树每个节点的值都加上比它大的节点的值。" class="headerlink" title="3、把二叉查找树每个节点的值都加上比它大的节点的值。"></a>3、把二叉查找树每个节点的值都加上比它大的节点的值。</h2><p>二叉查找树节点值 左 &lt; 中 &lt; 右<br>对于整棵二叉查找树，从大到小排序之后，从 1 到 n,第x个数 需要加上的值 是它前面所有数的和,即0不变，1=0+1 , 2=0+1+2 , 3=0+1+2+3。<br>二叉查找树按照 左 中 右遍历是从小到大,按照 右 中 左遍历是从大到小。</p>
<pre><code>private int sum = 0;
public TreeNode convertBST(TreeNode root){
    traver(root);
    return root;
}
private void traver(TreeNode node){
    if(node == null) return ;
    traver(node.right);
    sum += node.val;
    node.val = sum;
    traver(node.left);
}</code></pre><h2 id="4、二叉树查找树中两个节点的最近公共祖先"><a href="#4、二叉树查找树中两个节点的最近公共祖先" class="headerlink" title="4、二叉树查找树中两个节点的最近公共祖先"></a>4、二叉树查找树中两个节点的最近公共祖先</h2><p>两个节点 p q，值分别为 p.val q.val<br>若当前节点root的值在root.val在p q值之间，即root为p q的公共祖先<br>若root的值比p、q的值都大，则p、q的祖先在root 的左子树上<br>若root的值比p、的值都小，则p、q的祖先在root 的右子树上</p>
<pre><code>public TreeNode lowestCommonAncestor(TreeNode root , TreeNode p , TreeNode q){
    if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left , p , q);
    if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right , p , q);
    return root;
}</code></pre><h2 id="5、二叉树中两个两个节点的最低公共祖先"><a href="#5、二叉树中两个两个节点的最低公共祖先" class="headerlink" title="5、二叉树中两个两个节点的最低公共祖先"></a>5、二叉树中两个两个节点的最低公共祖先</h2><p>对于p、q两个节点，从根节点root开始遍历，若root等于p、q中的某个，则其为公共祖先。否则分别递归左右子树，若一个节点在左子树上一个节点在右子树上<br>则root为公共结点，若两个节点都在左子树上，则最低公共祖先在左子树上，右子树同理。</p>
<pre><code>public TreeNode lowestCommonAncestor(TreeNode root , TreeNode p , TreeNode q){
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left , p , q);
    TreeNode right = lowestCommonAncestor(root.right , p , q);
    //以下内容也可写为三目运算符
    if(left!=null&amp;&amp;right!=null) return root;
    else if(left!=null) return left;
    else if(right!=null) return right;
    else return null;
    //以上内容也可写为三目运算符:
    return left == null ? right : right == null? left : root;
    //left为null 时返回right,不为空时判断right是否为null, right为null则返回left 否则返回root;
}</code></pre><h2 id="6、将有序数组变为二叉查找树"><a href="#6、将有序数组变为二叉查找树" class="headerlink" title="6、将有序数组变为二叉查找树"></a>6、将有序数组变为二叉查找树</h2><p>把数组中点看做根，讲数组分为左右子树，再对左右子树做同样操作,类似二分查找。</p>
<pre><code>public TreeNode sortedArraytoBST(int [] num){
    if(num == null|| num.length == 0)return null;
    return help(num , 0 , num.length - 1);
}
private TreeNode helper(int []num , int l , int r){
    if(l&gt;r) return null;
    int m = (l+r)/2;
    TreeNode root = new TreeNode(num[m]);
    root.left = helper(num, l , m-1);
    root.right = helper(num, m+1 , r);
    return root;
}</code></pre><h2 id="7、根据有序链表构造平衡的二叉查找树"><a href="#7、根据有序链表构造平衡的二叉查找树" class="headerlink" title="7、根据有序链表构造平衡的二叉查找树"></a>7、根据有序链表构造平衡的二叉查找树</h2><p>取巧解法：先把有序链表转换为有序数组，问题就变成了有序数组构造二叉查找树问题即(6)<br>普通解法：定义函数，使用快慢指针，可以找到链表的中点。有了这个函数就可以和之前的有序数组构造二叉查找树问题类似了。<br>快慢指针找链表的中点有两种写法</p>
<pre><code>ListNode fast = head;
ListNode slow = head;
while(fast!=null){
    fast = fast.next;
    slow = slow.next;
    if(fast==null)break;
    fast = fast.next;
}</code></pre><p>//上面这种写法偶数个节点时slow指向中点右侧，奇数个节点时slow指向中间节点的下一个节点<br>例： 1 2 3 4 5 6<br>a: fast:1 slow:1<br>b: fast:2 slow:2 fast:3<br>c: fast:4 slow:3 fast:5<br>d: fast:6 slow:4 fast:null<br>e: 循环退出</p>
<p>例： 1 2 3 4 5 6 7<br>a: fast:1 slow:1<br>b: fast:2 slow:2 fast:3<br>c: fast:4 slow:3 fast:5<br>d: fast:6 slow:4 fast:7<br>e: fast:null slow:5  fast==null break;循环退出</p>
<pre><code>ListNode slow = head;
ListNode fast = head.next;
while(fast!=null &amp;&amp; fast.next!=null){
    slow = slow.next;
    fast = fast.next.next;
}</code></pre><p>//上面这种写法偶数个节点时slow指向中点左侧，奇数个节点时slow指向中间节点<br>例： 1 2 3 4 5 6<br>a: slow:1 fast:2<br>b: slow:2 fast:4<br>c: slow:3 fast:6<br>d: fast.next==null,循环停止</p>
<p>例： 1 2 3 4 5 6 7<br>a: slow:1 fast:2<br>b: slow:2 fast:4<br>c: slow:3 fast:6<br>d: slow:4 fast:null<br>e: fast==null,循环停止</p>
<pre><code>private ListNode getPreMid(ListNode node){
    ListNode slow = head;
    ListNode fast = head.next;
    ListNode pre = head;
    while(fast!=null &amp;&amp; fast.next!=null){
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    return pre;//本题所找到的pre 是slow节点的前一个节点,以便后续操作时同时取到中点和中点前一个节点
}
public TreeNode sortedListToBST(ListNode head){
    if(head == null)return null;
    if(head.next == null) return new TreeNode(head.val);//若链表只有一个节点，则直接将其变为二叉树节点即可。
    ListNode preMid = getPreMid(head);
    ListNode mid = preMid.next;
    preMid.next = null;//调用getPreMid函数获得了有序链表的中点和中点的前一个节点后，将链表从中点断开，问题变为两个链表的子问题，
                       //左边子问题的初始节点仍然为head,将mid转化为二叉树节点,右边子问题的初始节点为mid.next
    TreeNode t = new TreeNode(mid.val);
    t.left = sortedListToBST(head);
    t.right = sortedListToBST(mid.next);
    return t;
}</code></pre><h2 id="8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值"><a href="#8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值" class="headerlink" title="8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值"></a>8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值</h2><p>twosum问题的变体，解题方法是在有序数组中使用双指针，二叉查找树中序遍历即可变为有序数组</p>
<pre><code>private void inOrder(TreeNode node , List&lt;Integer&gt; nums){
    if(root == null)return;
    inOrder(root.left,nums);
    nums.add(root.val);
    inOrder(root.right,nums);
}//中序遍历把二叉查找树转为有序数组并存于nums中
public boolean findTarget(TreeNode root, int k){
    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    inOrder(root , nums);
    int i = 0 , j = nums.size() - 1;
    while(i &lt; j){
        if(nums.get(i)+nums.get(j)==k) {return true;}
        else if(nums.get(i)+nums.get(j)&gt;k){
        j--;
        }
        else{
            i++;
        }
    }
    return false;
}</code></pre><h2 id="9、在二叉查找树中查找两个节点之差的最小绝对值"><a href="#9、在二叉查找树中查找两个节点之差的最小绝对值" class="headerlink" title="9、在二叉查找树中查找两个节点之差的最小绝对值"></a>9、在二叉查找树中查找两个节点之差的最小绝对值</h2><p>中序遍历，遍历时取某一节点和其前一个节点，计算差值，取最小。</p>
<pre><code>private int minDiff = Integer.MAX_VALUE;
private TreeNode preNode = null;
private void inOrder(TreeNode node){
    if(node == null) return;
    inOrder(node.left);
    if(preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);
    preNode = node;
    inOrder(node.right);
}
public int getMinimumDifference(TreeNode root){
    inOrder(root);
    return minDiff;
}</code></pre><h2 id="10、寻找二叉查找树中出现次数最多的值"><a href="#10、寻找二叉查找树中出现次数最多的值" class="headerlink" title="10、寻找二叉查找树中出现次数最多的值"></a>10、寻找二叉查找树中出现次数最多的值</h2><pre><code>private int curCnt = 1;
private int MaxCnt = 1;
private TreeNode preNode = null;
public int [] findMode(TreeNode root){//中序遍历得到结果存入maxCntNums中再将其转化为数组ret
    List&lt;Integer&gt; maxCntNums = new ArrayList&lt;&gt;();
    inOrder(root,maxCntNums);
    int [] ret = new int[maxCntNums.size()];
    int idx = 0;
    for(int num: maxCntNums){
    ret[idx++] = num;
    }
    return ret;
}
private void inOrder(TreeNode node , List&lt;Integer&gt; nums){
    if(node ==null )return;
    inOrder(node.left, nums);
//累计相同数字出现次数
    if(preNode != null){
        if(preNode.val==node.val) curCnt++;
        else curCnt = 1;
    }
//若当前数字出现次数大于最大出现次数，则更新
    if(curCnt &gt; maxCnt){
        maxCnt = curCnt;
        nums.clear();
        nums.add(node.val);
    }else if (curCnt == maxCnt){//若当前数字出现次数等于最大出现次数，则增加一个众数
        nums.add(node.val);
    }
    preNode = node;
//
    inOrder(node.right,nums);
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" data-id="ck9jqdx8d00047wrgbb7d5neb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字典树Trie
        
      </div>
    </a>
  
  
    <a href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">二叉树类算法题2</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/26/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%E7%AE%97%E6%B3%95%E9%A2%98/">贪心思想算法题</a>
          </li>
        
          <li>
            <a href="/2020/04/25/Markdown%E5%86%99%E4%BD%9C/">Markdown写作</a>
          </li>
        
          <li>
            <a href="/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/">字典树Trie</a>
          </li>
        
          <li>
            <a href="/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>
          </li>
        
          <li>
            <a href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/">二叉树类算法题2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>