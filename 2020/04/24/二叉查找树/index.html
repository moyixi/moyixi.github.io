<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>二叉查找树 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="二叉查找树(BST)：根结点大于等于左子树所有节点，小于等于右子树所有节点.特点：中序遍历有序(由小到大)，那么按右 中 左 方式的遍历即由大到小的有序 1、给定一个二叉查找树和左右边界值，修剪二叉查找树，只保留边界值之内的数字。public TreeNode trimBST(TreeNode root , int L ,int R){    if(root == null) return nul">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉查找树">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="二叉查找树(BST)：根结点大于等于左子树所有节点，小于等于右子树所有节点.特点：中序遍历有序(由小到大)，那么按右 中 左 方式的遍历即由大到小的有序 1、给定一个二叉查找树和左右边界值，修剪二叉查找树，只保留边界值之内的数字。public TreeNode trimBST(TreeNode root , int L ,int R){    if(root == null) return nul">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-04-25T06:54:39.121Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-二叉查找树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" class="article-date">
  <time datetime="2020-04-24T06:38:09.331Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      二叉查找树
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>二叉查找树(BST)：根结点大于等于左子树所有节点，小于等于右子树所有节点.<br>特点：中序遍历有序(由小到大)，那么按右 中 左 方式的遍历即由大到小的有序</p>
<p>1、给定一个二叉查找树和左右边界值，修剪二叉查找树，只保留边界值之内的数字。<br>public TreeNode trimBST(TreeNode root , int L ,int R){<br>    if(root == null) return null;<br>    if(root.val &lt; L) return trimBST(root.right,L,R);<br>    //若当前root值小于左边界，则左子树可被抛弃，问题等同于修剪以root.right为根结点的子树<br>    if(root.val &gt; R) return trimBST(root.left,L,R);<br>    //若当前root值大于右边界，则右子树可被抛弃，问题等同于修剪以root.left为根结点的子树<br>    root.left = trimBST(root.left,L,R);<br>    root.right = trimBST(root.right,L,R);<br>    //经过上面两部判断后，root值都在L,R的范围之内，可将问题递归至左右结点。<br>    return root;<br>}</p>
<p>2.0、寻找二叉查找树由小到大第k个元素<br>因为二叉查找树中序遍历有序，所以中序遍历到第k个即可<br>private int cnt = 0;<br>private int val;</p>
<p>public int kthSmallest(TreeNode root , int k){<br>    inOrder(root, k);<br>    return val;<br>}</p>
<p>//类比于普通情况下的中序遍历<br>void dfs(TreeNode root){<br>    dfs(root.left);<br>    visit(root);<br>    dfs(root.right);<br>}</p>
<p>private void inOrder(TreeNode node,int k){//中序遍历找到第k个元素的过程<br>    if(node == null) return ;<br>    inOrder(node.left,k);<br>//<br>    cnt++;<br>    if(cnt == k){<br>        val = node.val;<br>        return;<br>    }<br>    //上面这一坨就是visit(root);讲的故事<br>//<br>    inOrder(node.right,k);<br>}</p>
<p>2.1、寻找二叉查找树由小到大第k个元素,递归解法<br>// count 函数计算以root为根节点的二叉树上有多少个节点。<br>public int count(TreeNode root){<br>    if(root == null) return 0;<br>    return 1 + count(root.left)+count(root.right);<br>}<br>//若以root.left 为根节点的二叉树上有n个结点则 root 是第 n+1个节点。<br>//那么进入此题判断逻辑，若 root.left 有k-1个节点，则root为所求的第k个节点。<br>//若root.left上的节点比k-1多，则抛弃右子树<br>//若root.left上的节点比k-1少，则抛弃左子树，并减去左子树上的节点个数和root节点，在右子树上继续进行本题。</p>
<p>public int kthSmallest(TreeNode root , int k){<br>    int leftcount = count(root.left);<br>    if(leftcount == k - 1) return root.val;<br>    if(leftcount  &gt; k - 1) return kthSmallest(root.left , k);<br>    return kthSmallset(root.right , k - leftcount - 1);<br>}</p>
<p>3、把二叉查找树每个节点的值都加上比它大的节点的值。<br>二叉查找树节点值 左 &lt; 中 &lt; 右<br>对于整棵二叉查找树，从大到小排序之后，从 1 到 n,第x个数 需要加上的值 是它前面所有数的和,即0不变，1=0+1 , 2=0+1+2 , 3=0+1+2+3。<br>二叉查找树按照 左 中 右遍历是从小到大,按照 右 中 左遍历是从大到小。<br>private int sum = 0;</p>
<p>public TreeNode convertBST(TreeNode root){<br>    traver(root);<br>    return root;<br>}</p>
<p>private void traver(TreeNode node){<br>    if(node == null) return ;<br>    traver(node.right);<br>    sum += node.val;<br>    node.val = sum;<br>    traver(node.left);<br>}</p>
<p>4、二叉树查找树中两个节点的最近公共祖先<br>两个节点 p q，值分别为 p.val q.val<br>若当前节点root的值在root.val在p q值之间，即root为p q的公共祖先<br>若root的值比p、q的值都大，则p、q的祖先在root 的左子树上<br>若root的值比p、的值都小，则p、q的祖先在root 的右子树上<br>public TreeNode lowestCommonAncestor(TreeNode root , TreeNode p , TreeNode q){<br>    if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left , p , q);<br>    if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right , p , q);<br>    return root;<br>}</p>
<p>5、二叉树中两个两个节点的最低公共祖先<br>对于p、q两个节点，从根节点root开始遍历，若root等于p、q中的某个，则其为公共祖先。否则分别递归左右子树，若一个节点在左子树上一个节点在右子树上<br>则root为公共结点，若两个节点都在左子树上，则最低公共祖先在左子树上，右子树同理。</p>
<p>public TreeNode lowestCommonAncestor(TreeNode root , TreeNode p , TreeNode q){<br>    if(root == null || root == p || root == q) return root;<br>    TreeNode left = lowestCommonAncestor(root.left , p , q);<br>    TreeNode right = lowestCommonAncestor(root.right , p , q);<br>    //以下内容也可写为三目运算符<br>    if(left!=null&amp;&amp;right!=null) return root;<br>    else if(left!=null) return left;<br>    else if(right!=null) return right;<br>    else return null;<br>    //以上内容也可写为三目运算符:<br>    return left == null ? right : right == null? left : root;<br>    //left为null 时返回right,不为空时判断right是否为null, right为null则返回left 否则返回root;<br>}</p>
<p>6、将有序数组变为二叉查找树<br>把数组中点看做根，讲数组分为左右子树，再对左右子树做同样操作,类似二分查找。<br>public TreeNode sortedArraytoBST(int [] num){<br>    if(num == null|| num.length == 0)return null;<br>    return help(num , 0 , num.length - 1);<br>}</p>
<p>private TreeNode helper(int []num , int l , int r){<br>    if(l&gt;r) return null;<br>    int m = (l+r)/2;<br>    TreeNode root = new TreeNode(num[m]);<br>    root.left = helper(num, l , m-1);<br>    root.right = helper(num, m+1 , r);<br>    return root;<br>}</p>
<p>7、根据有序链表构造平衡的二叉查找树<br>取巧解法：先把有序链表转换为有序数组，问题就变成了有序数组构造二叉查找树问题即(6)<br>普通解法：定义函数，使用快慢指针，可以找到链表的中点。有了这个函数就可以和之前的有序数组构造二叉查找树问题类似了。<br>快慢指针找链表的中点有两种写法</p>
<p>ListNode fast = head;<br>ListNode slow = head;<br>while(fast!=null){<br>    fast = fast.next;<br>    slow = slow.next;<br>    if(fast==null)break;<br>    fast = fast.next;<br>}<br>//上面这种写法偶数个节点时slow指向中点右侧，奇数个节点时slow指向中间节点的下一个节点<br>例： 1 2 3 4 5 6<br>a: fast:1 slow:1<br>b: fast:2 slow:2 fast:3<br>c: fast:4 slow:3 fast:5<br>d: fast:6 slow:4 fast:null<br>e: 循环退出</p>
<p>例： 1 2 3 4 5 6 7<br>a: fast:1 slow:1<br>b: fast:2 slow:2 fast:3<br>c: fast:4 slow:3 fast:5<br>d: fast:6 slow:4 fast:7<br>e: fast:null slow:5  fast==null break;循环退出</p>
<p>ListNode slow = head;<br>ListNode fast = head.next;<br>while(fast!=null &amp;&amp; fast.next!=null){<br>    slow = slow.next;<br>    fast = fast.next.next;<br>}<br>//上面这种写法偶数个节点时slow指向中点左侧，奇数个节点时slow指向中间节点<br>例： 1 2 3 4 5 6<br>a: slow:1 fast:2<br>b: slow:2 fast:4<br>c: slow:3 fast:6<br>d: fast.next==null,循环停止</p>
<p>例： 1 2 3 4 5 6 7<br>a: slow:1 fast:2<br>b: slow:2 fast:4<br>c: slow:3 fast:6<br>d: slow:4 fast:null<br>e: fast==null,循环停止</p>
<p>private ListNode getPreMid(ListNode node){<br>    ListNode slow = head;<br>    ListNode fast = head.next;<br>    ListNode pre = head;<br>    while(fast!=null &amp;&amp; fast.next!=null){<br>        pre = slow;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    }<br>    return pre;//本题所找到的pre 是slow节点的前一个节点,以便后续操作时同时取到中点和中点前一个节点<br>}</p>
<p>public TreeNode sortedListToBST(ListNode head){<br>    if(head == null)return null;<br>    if(head.next == null) return new TreeNode(head.val);//若链表只有一个节点，则直接将其变为二叉树节点即可。<br>    ListNode preMid = getPreMid(head);<br>    ListNode mid = preMid.next;<br>    preMid.next = null;//调用getPreMid函数获得了有序链表的中点和中点的前一个节点后，将链表从中点断开，问题变为两个链表的子问题，<br>                       //左边子问题的初始节点仍然为head,将mid转化为二叉树节点,右边子问题的初始节点为mid.next<br>    TreeNode t = new TreeNode(mid.val);<br>    t.left = sortedListToBST(head);<br>    t.right = sortedListToBST(mid.next);<br>    return t;<br>}</p>
<p>8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值</p>
<p>twosum问题的变体，解题方法是在有序数组中使用双指针，二叉查找树中序遍历即可变为有序数组</p>
<p>private void inOrder(TreeNode node , List<Integer> nums){<br>    if(root == null)return;<br>    inOrder(root.left,nums);<br>    nums.add(root.val);<br>    inOrder(root.right,nums);<br>}//中序遍历把二叉查找树转为有序数组并存于nums中</p>
<p>public boolean findTarget(TreeNode root, int k){<br>    List<Integer> nums = new ArrayList&lt;&gt;();<br>    inOrder(root , nums);<br>    int i = 0 , j = nums.size() - 1;<br>    while(i &lt; j){<br>        if(nums.get(i)+nums.get(j)==k) {return true;}<br>        else if(nums.get(i)+nums.get(j)&gt;k){<br>        j–;<br>        }<br>        else{<br>            i++;<br>        }<br>    }<br>    return false;<br>}</p>
<p>9、在二叉查找树中查找两个节点之差的最小绝对值<br>中序遍历，遍历时取某一节点和其前一个节点，计算差值，取最小。</p>
<p>private int minDiff = Integer.MAX_VALUE;<br>private TreeNode preNode = null;</p>
<p>private void inOrder(TreeNode node){<br>    if(node == null) return;<br>    inOrder(node.left);<br>    if(preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);<br>    preNode = node;<br>    inOrder(node.right);<br>}</p>
<p>public int getMinimumDifference(TreeNode root){<br>    inOrder(root);<br>    return minDiff;<br>}</p>
<p>10、寻找二叉查找树中出现次数最多的值</p>
<p>private int curCnt = 1;<br>private int MaxCnt = 1;<br>private TreeNode preNode = null;</p>
<p>public int [] findMode(TreeNode root){//中序遍历得到结果存入maxCntNums中再将其转化为数组ret<br>    List<Integer> maxCntNums = new ArrayList&lt;&gt;();<br>    inOrder(root,maxCntNums);<br>    int [] ret = new int[maxCntNums.size()];<br>    int idx = 0;<br>    for(int num: maxCntNums){<br>    ret[idx++] = num;<br>    }<br>    return ret;<br>}</p>
<p>private void inOrder(TreeNode node , List<Integer> nums){<br>    if(node ==null )return;<br>    inOrder(node.left, nums);</p>
<p>//累计相同数字出现次数<br>    if(preNode != null){<br>        if(preNode.val==node.val) curCnt++;<br>        else curCnt = 1;<br>    }</p>
<p>//若当前数字出现次数大于最大出现次数，则更新<br>    if(curCnt &gt; maxCnt){<br>        maxCnt = curCnt;<br>        nums.clear();<br>        nums.add(node.val);<br>    }else if (curCnt == maxCnt){//若当前数字出现次数等于最大出现次数，则增加一个众数<br>        nums.add(node.val);<br>    }<br>    preNode = node;<br>//<br>    inOrder(node.right,nums);<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" data-id="ck9fe9kd00003s4rghvh32cgm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字典树Trie
        
      </div>
    </a>
  
  
    <a href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">二叉树类算法题2</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/25/Markdown%E5%86%99%E4%BD%9C/">Markdown写作</a>
          </li>
        
          <li>
            <a href="/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/">字典树Trie</a>
          </li>
        
          <li>
            <a href="/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>
          </li>
        
          <li>
            <a href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/">二叉树类算法题2</a>
          </li>
        
          <li>
            <a href="/2020/04/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%981/">二叉树类算法题1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>