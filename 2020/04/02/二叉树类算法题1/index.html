<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="二叉树类题目多考虑递归，在处理完root之后，root的左右子树的处理方法都是一致的，处理root过程中，要先考虑到各种null情况。 二叉树两节点的最长路径二叉树的两节点的最长路径，要么两节点都在左子树上，要么两节点都在右子树上，要么一个节点在左子树一个节点在右子树，若一个节点在左子树一个节点在右子树，即求左右子树不包括根节点的高度和+1故根结点为root的二叉树的两节点最长路径 = Max(左">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树类算法题1">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;02&#x2F;%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%981&#x2F;index.html">
<meta property="og:site_name" content="莫一兮的个人博客">
<meta property="og:description" content="二叉树类题目多考虑递归，在处理完root之后，root的左右子树的处理方法都是一致的，处理root过程中，要先考虑到各种null情况。 二叉树两节点的最长路径二叉树的两节点的最长路径，要么两节点都在左子树上，要么两节点都在右子树上，要么一个节点在左子树一个节点在右子树，若一个节点在左子树一个节点在右子树，即求左右子树不包括根节点的高度和+1故根结点为root的二叉树的两节点最长路径 = Max(左">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-04-28T11:12:23.461Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/02/二叉树类算法题1/"/>





  <title>二叉树类算法题1 | 莫一兮的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">莫一兮的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%981/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="莫一兮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫一兮的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">二叉树类算法题1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-02T14:50:46+08:00">
                2020-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>二叉树类题目多考虑递归，在处理完root之后，root的左右子树的处理方法都是一致的，处理root过程中，要先考虑到各种null情况。</p>
<h2 id="二叉树两节点的最长路径"><a href="#二叉树两节点的最长路径" class="headerlink" title="二叉树两节点的最长路径"></a>二叉树两节点的最长路径</h2><p>二叉树的两节点的最长路径，要么两节点都在左子树上，要么两节点都在右子树上，要么一个节点在左子树一个节点在右子树，若一个节点在左子树一个节点在右子树，即求左右子树不包括根节点的高度和+1<br>故根结点为root的二叉树的两节点最长路径 = Max(左子树的最长路径，右子树的最长路径，左子树深度(去根)+右子树深度(去根)+1)即<br>    public class solution {<br>    int max = 0;<br>    public int diameterOfBinaryTree(TreeNode root){<br>        getDepth(root);<br>        return max;<br>    }</p>
<pre><code>private int getDepth(TreeNode root){//返回树的最大深度
    if(root == null)
    return 0;
    int l = getDepth(root.left);
    int r = getDepth(root.right);
    int max = Math.max(max , l+r);
    return Math.max(l,r)+1;
    }
}</code></pre><h2 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树 "></a>反转二叉树 </h2><p>常见的递归操作题<br>    public TreeNode invertTree(TreeNode root){<br>        if(root == null) return null;<br>        TreeNode left = root.left;//记录root.left防止丢失<br>        root.left = invertTree(root.right);<br>        root.right = invertTree(left);<br>        return root;<br>    }</p>
<h2 id="归并两棵二叉树"><a href="#归并两棵二叉树" class="headerlink" title="归并两棵二叉树"></a>归并两棵二叉树</h2><pre><code>public TreeNode MergeTree(TreeNode tree1 , TreeNode tree2){
    if(tree1 == null &amp;&amp; tree2 == null)return null;
    if(tree1 == null) return tree2;
    if(tree2 == null) return tree1;
    TreeNode root = new TreeNode(tree1.val + tree2.val);
    root.left = MergeTree(tree1.left, tree2.left);
    root.right = MergeTree(tree1.right , tree2.right);
    return root;
}</code></pre><h2 id="判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径"><a href="#判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径" class="headerlink" title="判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径"></a>判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径</h2><p>路径要么在左子树上，要么在右子树上。<br>走向左右子树后，目标数减去根结点数值，对左右子树做递归。<br>因为必须要走到叶子结点后结束，即当前节点没有左右节点时判断是否为目标数。</p>
<pre><code>public boolean hasPathsum(TreeNode root , int sum){
    if(root == null) return false;
    if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true;
    return hasPathsum(root.left,sum-root.val) || hasPathsum(root.right, sum-root.val);
}</code></pre><h2 id="统计二叉树中路径和等于目标数的路径数量"><a href="#统计二叉树中路径和等于目标数的路径数量" class="headerlink" title="统计二叉树中路径和等于目标数的路径数量"></a>统计二叉树中路径和等于目标数的路径数量</h2><p>不需要从根节点起到叶子节点止，但需要连续。</p>
<p>整个判断过程，先从根节点开始走路径，然后递归左右子节点。<br>判断过程中，省去了验证最后一个结点为叶子结点的过程。<br>然后再做一次递归，从这个根节点的左右子树开始判断，以左右子树为根结点再判断一次是否符合题意。即本题有两种递归，一种是递归的判断以某点作为起点是否存在路径，一种是递归的找起点。</p>
<pre><code>public int pathSum(TreeNode root , int sum){//这个函数是递归的找起始节点。
    if(root == null) return 0;
    int result = pathSumStartWithRoot(root,sum)+pathSum(root.left , sum)+pathSum(root.right , sum);
    return result;
}

private int pathSumStartWithRoot(TreeNode root , int sum){//这个函数可以判断出从根节点开始的路径和是否满足目标数
    if(root == null) return 0;
    int result = 0;
    if(root.val == sum) result ++;
    result += pathSumStartWithRoot(root.left , sum - root.val) + pathSumStarrtWithRoot(root.right , sum - root.val);
    return result;
}</code></pre><h2 id="判断A树是否为B树的子树"><a href="#判断A树是否为B树的子树" class="headerlink" title="判断A树是否为B树的子树"></a>判断A树是否为B树的子树</h2><p>若A树是B树的子树，那必和B树的一部分相等,以下为判断两树是否相等<br>方法：若都为null，则相等，若只有一个为null，则不相等，若数值不同则不相等，递归对比他们的左右子树。</p>
<p>判断A树是否和B树相等之后，再递归比较A树是否和B树的左右子树相等即可判断A树是否是B树的子树,当B树为null时递归退出</p>
<pre><code>public boolean isSubtree(TreeNode A , TreeNode B){
    if(B==null) return false;
    return isSame(A,B)||isSubtree(A,B.left)||isSubtree(A,B.right);
}
private boolean isSame(TreeNode A,TreeNode B){
    if(A == null &amp;&amp; B == null) return true;
    if(A == null || B == null) return false;
    //都为空排除后的或证明了一个为空一个不为空
    if(A.val != B.val) return false;
    return isSame(A.left,B.left)&amp;&amp;isSame(A.right,B.right);
}</code></pre><h2 id="判断一个树是否左右对称"><a href="#判断一个树是否左右对称" class="headerlink" title="判断一个树是否左右对称"></a>判断一个树是否左右对称</h2><p>此题和子树判断题类似，可以将左右对称变为判断两个树是否相等</p>
<pre><code>public boolean isSymmetric(Tree root){
    if(root==null) return true;//之所以null时返回true是因为比对到null则说明递归到底，比对成功了
    return isSame(root.left, root.right);
}</code></pre><h2 id="树的最小路径"><a href="#树的最小路径" class="headerlink" title="树的最小路径"></a>树的最小路径</h2><pre><code>public int minDepth(TreeNode root){
    if(root == null) return 0;//若这个树为空则高度为0
    if(root.left == null &amp;&amp; root.right == null) return 1;//若这个树左右子树同时为空则高度为1
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    if(leftDepth == 0)
    //若这个树左子树为空，则长度为右子树长度+1
        return rightDepth + 1;
    else if(rightDepth == 0)
    //若这个树右子树为空，则长度为左子树长度+1
        return leftDepth + 1;
    else
        return min(leftDepth,rightDepth) + 1;
     //若左右子树都不为空，则长度为左右子树的较小值+1
 }</code></pre><p>以上代码可优化为</p>
<pre><code>public int minDepth(TreeNode root){
    if(root == null)return 0;
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    if(leftDepth == 0 || rightDepth == 0) {
        return leftDepth+rightDepth+1;
    }
    //leftDepth和rightDepth都不为0才返回下一御酒
    return Math.min(leftDepth,rightDepth)+1;
}</code></pre><h2 id="统计左叶子节点的和"><a href="#统计左叶子节点的和" class="headerlink" title="统计左叶子节点的和"></a>统计左叶子节点的和</h2><p>//若一个结点的左孩子是叶节点，即他的左孩子是左叶子结点，累加左孩子数值之后再递归判断这个结点的右子树<br>//否则，递归判断这个结点的左右子树</p>
<pre><code>public int sumOfLeftLeaves(TreeNode root){
    if(root == null) return 0;
    if(isLeaf(root.left)){
        return root.left.val + sumOfLeftLeaves(root.right);
    }
    return sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);
}
//判断一个节点是不是叶子节点
private boolean isLeaf(TreeNode node){
    if(node == null) return false;
    return node.left == null &amp;&amp; node.right == null;
}</code></pre><h2 id="相同结点值的最大路径长度"><a href="#相同结点值的最大路径长度" class="headerlink" title="相同结点值的最大路径长度"></a>相同结点值的最大路径长度</h2><p>需要用到深度优先搜索</p>
<p>树的递归题目中，写出的左右子节点的递归，可以默认写出时即已经是正确的结果，再进行后续。</p>
<pre><code>private int path = 0;
public int longestUnivaluePath(TreeNode root){
    dfs(root);
    return path;
}
private int dfs(TreeNode root){
    if(root == null)return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    //dfs的子函数return的值可从 最外层的dfs看出。
    // Math.max(leftPath,rightPath)即，返回的是 左路径和右路径中的较大值。
    //即 left返回的是 root左节点 的左右路径中的较大值
    // right 返回的是root右节点 的左右路径中的较大值
    int leftPath = root.left!=null &amp;&amp; root.left.val == root.val ? left+1 : 0;
    int rightPath = root.right!=null &amp;&amp; root.right.val == root.val ? right+1 : 0;
    //获得了左右子节点的左右路径中的较长者之后，对于当前的root节点而言，若root节点的值和左节点相等，则左路径+1，类似的右路径+1。
    path = Math.max(path,leftPath + rightPath);
    //path用来记录并更新一个以root为根结点的树的相同节点最大路径长度
    return Math.max(leftPath,rightPath);
    //所返回的值是之前计算过的左右路径中的较大值。
}</code></pre><h2 id="House-Robber-III"><a href="#House-Robber-III" class="headerlink" title="House Robber III"></a>House Robber III</h2><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police<br>间隔遍历：在二叉树中取点，要求任意两点不相邻，求所取点之和的最大值为多少。</p>
<p>对于root为根的二叉树，最优解为取根结点+四个孙子节点或 取两个孩子结点之间的较大值。即</p>
<p>f(root) = max(root.val + f(ll) + f(lr) + f(rl) + f(rr) , f(l)+f(r))</p>
<pre><code>public int rob(TreeNode root){
    if(root == null) return 0;
    int val1 = root.val;
    if(root.left!=null){
    val1 = val1 + rob(root.left.left) + rob(root.left.right); 
    }
    if(root.right!=null){
    val1 = val1 + rob(root.right.left) + rob(
    root.right.right);
    }
    int val2 = rob(root.left)+rob(root.right);
    return Math.max(val1,val2);
}</code></pre><h2 id="求二叉树中第二小的值"><a href="#求二叉树中第二小的值" class="headerlink" title="求二叉树中第二小的值"></a>求二叉树中第二小的值</h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>
<p>定义两个变量，一个保存最小值一个保存次小值。再定义一个flag递归过程中，若找到过次小值则改变flag，返回次小值。若未找到过次小值，则返回-1；</p>
<pre><code>int first = Integer.MAX_VALUE, second = Integer.MAX_VALUE;
int flag = 0;
public int findSecondMinimumValue(TreeNode root){
    helper(root);
    return flag == 0 ? -1:second;
}
public void helper(TreeNode root){
    if(root == null)
    return ;
    if(root.val &lt; first){
        second = first;
        first = root.val;
    }else if(root.val &lt;= second &amp;&amp; root.val &gt; first){
        flag++;
        second = root.val;
    }
    helper(root.left);
    helper(root.right);
}</code></pre><p>因为这个二叉树父节点的值必≤子节点的值，故根结点必定为最小值，所以第二小的值必在左右两个子树之中，<br>倘若左右两个子树中的最小值都不和根结点相等，则第二小的值是左右两个子树最小值中的较小值。<br>倘若左(右)子节点和父节点的值相等，则需要在左(右)子树中找出第二小的值来与右(左)子树的最小值一起比较出一个较小值出来。这样才能保证比对出来的是真正的第二小的值。<br>简而言之，要在左右子树中分别找出和根结点不相等的最小值。<br>这两个最小值中的较小者就是第二小的值。</p>
<p>若左(右)子节点和根节点相等，才需要递归的找左(右)子树的次小值。<br>因为左右子树作为一个单独的树做此题的判断，root.left必定是left树的最小值，递归后找到的次小值也即左子树除根结点外的最小值。<br>否则直接取左右子节点中的较小值即可。</p>
<pre><code>public int findSecondMinimumValue(TreeNode root){
    if(root == null) return -1;
    //递归返回条件 1 节点为空，树没有次小值。
    if(root.val==null &amp;&amp; root.right == null) return -1;
    //递归返回条件 2 节点没有子节点，树没有次小值。
    int leftVal = root.left.val;
    int rightVal = root.right.val;
    if(leftVal == root.val) {
        leftVal ==     findSecondMinimumValue(root.left);
    }
    if(rightVal == root.val){
        rightVal == findSecondMinimumValue(root.right);
    }
    if(leftVal != -1 &amp;&amp; rightVal != -1){
        return Math.min(leftVal,rightVal);
        //递归返回条件 3 因为左右节点若与根结点相等则会继续递归，递归到找到没有子节点的节点 返回-1为止。
        //若都不为 -1 则说明两边都没有一直递归到树的末端，而是在中途由于某个子节点不和父节点相等而返回
        //即满足，左右子节点都不和父节点的值相等。
        //那么这两个数值中的较小值就是整个树的次小值。
    }
    if(leftVal != -1) return leftVal;
    // 递归返回条件4 在上一步判断完了两个子节点都不和根结点相等之后，再继续执行则说明，必有一个子节点和根结点值相等，此时若 左子节点不为-1，即左子节点不和根结点相等，即右子节点和根节点相等，此时次小值为左子节点。
    return rightVal;
}</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="next" title="算法笔记">
                <i class="fa fa-chevron-left"></i> 算法笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/" rel="prev" title="二叉树类算法题2">
                二叉树类算法题2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">莫一兮</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树两节点的最长路径"><span class="nav-number">1.</span> <span class="nav-text">二叉树两节点的最长路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反转二叉树"><span class="nav-number">2.</span> <span class="nav-text">反转二叉树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并两棵二叉树"><span class="nav-number">3.</span> <span class="nav-text">归并两棵二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径"><span class="nav-number">4.</span> <span class="nav-text">判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计二叉树中路径和等于目标数的路径数量"><span class="nav-number">5.</span> <span class="nav-text">统计二叉树中路径和等于目标数的路径数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断A树是否为B树的子树"><span class="nav-number">6.</span> <span class="nav-text">判断A树是否为B树的子树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断一个树是否左右对称"><span class="nav-number">7.</span> <span class="nav-text">判断一个树是否左右对称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树的最小路径"><span class="nav-number">8.</span> <span class="nav-text">树的最小路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计左叶子节点的和"><span class="nav-number">9.</span> <span class="nav-text">统计左叶子节点的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相同结点值的最大路径长度"><span class="nav-number">10.</span> <span class="nav-text">相同结点值的最大路径长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-Robber-III"><span class="nav-number">11.</span> <span class="nav-text">House Robber III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#求二叉树中第二小的值"><span class="nav-number">12.</span> <span class="nav-text">求二叉树中第二小的值</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">莫一兮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
