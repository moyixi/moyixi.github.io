<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-贪心思想算法题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%E7%AE%97%E6%B3%95%E9%A2%98/" class="article-date">
  <time datetime="2020-04-26T04:33:03.704Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%E7%AE%97%E6%B3%95%E9%A2%98/">贪心思想算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h1><h2 id="1-分配饼干"><a href="#1-分配饼干" class="headerlink" title="1.分配饼干"></a>1.分配饼干</h2><p>每个孩子都有一个满足度grid，每个饼干都有一个大小size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。<br>即存在 grid 和 size 两个数组，先用小饼干去满足需求小的孩子，以便后面让大饼干满足需求大的孩子，所以要先对数组排序。</p>
<pre><code>public int findContentChildren(int grid[],int size[]){
    if(grid == null || size == null) return 0;
    Arrays.sort(grid);
    Arrays.sort(size);
    int gi = 0 , si = 0;
    while(gi &lt; grid.length &amp;&amp; si &lt; size.length){
        if(grid[gi] &lt; size(si)){//若孩子的需求&lt;饼干的大小，则满足了,满足的孩子数量+1。
        gi++;
        }
        si++;//若孩子满足了，饼干后移一位，若孩子不满足，说明饼干不够大，试下一个饼干是否满足。
    }
    return gi;//gi即为最终满足的孩子数
}</code></pre><h2 id="2-不重叠的区间个数"><a href="#2-不重叠的区间个数" class="headerlink" title="2.不重叠的区间个数"></a>2.不重叠的区间个数</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。<br>例如：输入： [ [1,2], [2,3], [3,4], [1,3] ]，移除[1,3]后不重叠，输出：1<br>     输入: [ [1,2], [1,2], [1,2] ]，移除两个[1,2]后不重叠，输出：2</p>
<p>这题和活动时间安排问题类似，为最大化安排，需要先安排结束的早的事情，此题也是一样，先安排右边界小的区间，这样留的空间就越大</p>
<pre><code>public int eraseOverlapIntervals(int [][] intervals){
    if(intervals.length == 0) return 0;
    Arrays.sort(intervals , new Comparator&lt;int [] &gt;() {
        public int compare(int []a1 , int []a2){
            return a1[1] - a2[1];
        }
        });
    int count = 1;
    int end = intervals[0][1];
    for(int i = 1 ; i &lt; intervals.length ; i++){
        if(intervals[i][0]&lt;end){
            continue;
        }
        end = intervals[i][1];
        count++;
    } 
    return intervals.length - count;
}</code></pre><h2 id="3-投飞镖刺破气球"><a href="#3-投飞镖刺破气球" class="headerlink" title="3.投飞镖刺破气球"></a>3.投飞镖刺破气球</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>此题也是找重复区间的题目，区别在于上一题连续的区间不算重复，这一题连续的区间算重复</p>
<pre><code>public int findMinArrowShots(int [][]points){
    if(points == 0) return 0;
    Arrays.sort(points, new Comparator&lt;int [] &gt;(){
        public int compare(int []a1 , int []a2){
            return a1[1] - a2[1];
        }
        });
    int count = 1;
    int end = points[0][1];
    for(int i = 1 ; i &lt; points.length ; i++){
        if(points[i][0] &lt;= end){
            continue;
        }
        end = points[i][1];
        count++;
    }
    return count;
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%E7%AE%97%E6%B3%95%E9%A2%98/" data-id="ck9gmoptb0008e0rg4lea72p4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Markdown写作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/25/Markdown%E5%86%99%E4%BD%9C/" class="article-date">
  <time datetime="2020-04-25T07:56:11.956Z" itemprop="datePublished">2020-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/25/Markdown%E5%86%99%E4%BD%9C/">Markdown写作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、 普通文本 直接输入<br>例： 普通文本</p>
<p>2、标题 两种方法 a、#加空格加内容，多级标题就用多个# b、标题下用多个 = [一级标题]或多个 - [二级标题]</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题 "></a>标题 </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>3、斜体和粗体(前后加 * 一个是斜体，两个是粗体，三个是粗斜体，星号和内容之间不可加空格)</p>
<p><em>斜体</em><br><strong>粗体</strong><br><strong><em>粗斜体</em></strong></p>
<p>4、链接和图片的插入、空格后的英文引号里的内容为鼠标悬停时的title</p>
<p>链接插入的几种方法：中括号加小括号 或者直接尖括号内输入网址<br>a、<br><a href="https://www.bilibili.com" target="_blank" rel="noopener">哔哩哔哩</a><br><a href="https://www.bilibili.com" target="_blank" rel="noopener" title="bilibili">哔哩哔哩</a><br>b、<br><a href="https://www.bilibili.com" target="_blank" rel="noopener">https://www.bilibili.com</a></p>
<p>图片插入方法:感叹号加中括号加小括号<br>网络图片：<br><img src="https://p0.ssl.qhimg.com/t010981b15897665b3d.webp" alt="这是网络图片名称"></p>
<p>本地图片：本地图片也区分为相对位置绝对位置略过不表<br><img src="../../pic/%E6%99%9A%E5%AA%9A.jpg" alt="这是本地的图片" title="这是图片title"></p>
<p>5、脚注(脚注id必须唯一)<br>我需要一个脚注<a href="我是你的脚注">^er</a></p>
<p>我也需要一个脚注[^12306]<br>[^12306]:我是第二个脚注</p>
<p>6、引用段落</p>
<blockquote>
<p>第一层引用</p>
<blockquote>
<p>第二层引用</p>
<blockquote>
<p>第三层引用</p>
</blockquote>
</blockquote>
</blockquote>
<p>7、代码块儿<br><code>System.out.println(Hello World)</code></p>
<p>代码区：连打四个空格或 Tab<br>    System.out.println(Hello World)</p>
<pre><code>System.out.println(Hello World)</code></pre><p>8、下划线：三个* 或三个- 或三个_</p>
<hr>
<hr>
<hr>
<p>删除线：文字前后加两个~<br><del>被删除了</del></p>
<p>9、无序列表 在前面加上 * 或- 或+</p>
<ul>
<li>111</li>
</ul>
<ul>
<li>222</li>
</ul>
<ul>
<li>333<br>有序列表 数字 点儿[.] 空格</li>
</ul>
<p>1.<br>2. </p>
<p>多级列表</p>
<ul>
<li>一级 <ul>
<li>二级 </li>
<li>三级 </li>
</ul>
</li>
</ul>
<p>10、表格<br>列与列与用 | 分开 ,第二行 多个- 加前后的 : 表明对齐方式 :在左左对齐，在右右对齐，左右都有居中</p>
<table>
<thead>
<tr>
<th align="center">表格</th>
<th align="left">表格</th>
<th align="right">表格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一</td>
<td align="left">二</td>
<td align="right">三</td>
</tr>
<tr>
<td align="center">四</td>
<td align="left">五</td>
<td align="right">六</td>
</tr>
<tr>
<td align="center">七</td>
<td align="left">八</td>
<td align="right">九</td>
</tr>
</tbody></table>
<p>11、排版:使用html<br>文字中输入回车只是空格</p>
<p>111<br>222</p>
<p>两个空格后再输入回车才是换行<br>111<br>222</p>
<p>段前首行缩进 一个、半个、四分之一字符//&emsp;、&ensp;、&nbsp;<br>一二三<br>&emsp; 四五六<br>&ensp; 七八九<br>&nbsp; 十沟圈</p>
<p>居中使用//<div align=center> </div></p>
<div align=center>居中</div>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/25/Markdown%E5%86%99%E4%BD%9C/" data-id="ck9gmops10000e0rg5nhc2pfb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-字典树Trie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/" class="article-date">
  <time datetime="2020-04-25T06:56:49.176Z" itemprop="datePublished">2020-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/">字典树Trie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>字典树、前缀树、Trie 用于判断字符串是否存在或是否具有某种字符串前缀</p>
<p>实现前缀树：<br>插入、查找、查找前缀功能</p>
<p>class Trie{</p>
<p>public Trie(){</p>
<p>}<br>private class Node{<br>    Node[] childs = new Node[26];<br>    boolean isWord;<br>}</p>
<p>private Node root = new Node();<br>private int indexForChar(char c){<br>    return c - ‘a’;<br>}</p>
<p>public void insert(String word){<br>    insert(word,root);<br>}<br>private void insert(String word,Node node){<br>    if(node == null) return ;<br>    if(word.length == 0){<br>        node.isWord == true;<br>        return ;<br>    }<br>    int index = indexForChar(word.charAt(0));<br>    if(node.childs[index] == null){<br>        node.childs[index] = new Node();<br>    }<br>    insert(word.substring(1),node.childs[index]);<br>}</p>
<p>public boolean search(String word){<br>    return search(word,root);<br>}</p>
<p>private boolean search(String word,Node node){<br>    if(node == null)return false;<br>    if(word.length()==0) return node.isWord;<br>    int index = indexForChar(word.charAt(0));<br>    return search(word.substring(1),node.childs[index]);<br>}</p>
<p>public boolean startsWith(String prefix) {<br>        return startWith(prefix, root);<br>}</p>
<p>private boolean startWith(String prefix, Node node) {<br>    if (node == null) return false;<br>    if (prefix.length() == 0) return true;<br>    int index = indexForChar(prefix.charAt(0));<br>    return startWith(prefix.substring(1), node.childs[index]);<br>}<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/" data-id="ck9gmopt70006e0rg6ii18g7z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-二叉查找树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" class="article-date">
  <time datetime="2020-04-24T06:38:09.331Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>二叉查找树(BST)：根结点大于等于左子树所有节点，小于等于右子树所有节点.<br>特点：中序遍历有序(由小到大)，那么按右 中 左 方式的遍历即由大到小的有序</p>
<h2 id="1、修建二叉查找树"><a href="#1、修建二叉查找树" class="headerlink" title="1、修建二叉查找树"></a>1、修建二叉查找树</h2><p>给定一个二叉查找树和左右边界值，修剪二叉查找树，只保留边界值之内的数字。</p>
<pre><code>public TreeNode trimBST(TreeNode root , int L ,int R){
    if(root == null) return null;
    if(root.val &lt; L) return trimBST(root.right,L,R);
    //若当前root值小于左边界，则左子树可被抛弃，问题等同于修剪以root.right为根结点的子树
    if(root.val &gt; R) return trimBST(root.left,L,R);
    //若当前root值大于右边界，则右子树可被抛弃，问题等同于修剪以root.left为根结点的子树
    root.left = trimBST(root.left,L,R);
    root.right = trimBST(root.right,L,R);
    //经过上面两部判断后，root值都在L,R的范围之内，可将问题递归至左右结点。
    return root;
}</code></pre><h2 id="2-0、寻找二叉查找树由小到大第k个元素"><a href="#2-0、寻找二叉查找树由小到大第k个元素" class="headerlink" title="2.0、寻找二叉查找树由小到大第k个元素"></a>2.0、寻找二叉查找树由小到大第k个元素</h2><p>因为二叉查找树中序遍历有序，所以中序遍历到第k个即可</p>
<pre><code>private int cnt = 0;
private int val;
public int kthSmallest(TreeNode root , int k){
    inOrder(root, k);
    return val;
}
//类比于普通情况下的中序遍历
void dfs(TreeNode root){
    dfs(root.left);
    visit(root);
    dfs(root.right);
}
private void inOrder(TreeNode node,int k){//中序遍历找到第k个元素的过程
    if(node == null) return ;
    inOrder(node.left,k);
//
    cnt++;
    if(cnt == k){
        val = node.val;
        return;
    }
    //上面这一坨就是visit(root);讲的故事
//
    inOrder(node.right,k);
}</code></pre><h2 id="2-1、寻找二叉查找树由小到大第k个元素-递归解法"><a href="#2-1、寻找二叉查找树由小到大第k个元素-递归解法" class="headerlink" title="2.1、寻找二叉查找树由小到大第k个元素,递归解法"></a>2.1、寻找二叉查找树由小到大第k个元素,递归解法</h2><pre><code>// count 函数计算以root为根节点的二叉树上有多少个节点。
public int count(TreeNode root){
    if(root == null) return 0;
    return 1 + count(root.left)+count(root.right);
}
//若以root.left 为根节点的二叉树上有n个结点则 root 是第 n+1个节点。
//那么进入此题判断逻辑，若 root.left 有k-1个节点，则root为所求的第k个节点。
//若root.left上的节点比k-1多，则抛弃右子树
//若root.left上的节点比k-1少，则抛弃左子树，并减去左子树上的节点个数和root节点，在右子树上继续进行本题。
public int kthSmallest(TreeNode root , int k){
    int leftcount = count(root.left);
    if(leftcount == k - 1) return root.val;
    if(leftcount  &gt; k - 1) return kthSmallest(root.left , k);
    return kthSmallset(root.right , k - leftcount - 1);
}</code></pre><h2 id="3、把二叉查找树每个节点的值都加上比它大的节点的值。"><a href="#3、把二叉查找树每个节点的值都加上比它大的节点的值。" class="headerlink" title="3、把二叉查找树每个节点的值都加上比它大的节点的值。"></a>3、把二叉查找树每个节点的值都加上比它大的节点的值。</h2><p>二叉查找树节点值 左 &lt; 中 &lt; 右<br>对于整棵二叉查找树，从大到小排序之后，从 1 到 n,第x个数 需要加上的值 是它前面所有数的和,即0不变，1=0+1 , 2=0+1+2 , 3=0+1+2+3。<br>二叉查找树按照 左 中 右遍历是从小到大,按照 右 中 左遍历是从大到小。</p>
<pre><code>private int sum = 0;
public TreeNode convertBST(TreeNode root){
    traver(root);
    return root;
}
private void traver(TreeNode node){
    if(node == null) return ;
    traver(node.right);
    sum += node.val;
    node.val = sum;
    traver(node.left);
}</code></pre><h2 id="4、二叉树查找树中两个节点的最近公共祖先"><a href="#4、二叉树查找树中两个节点的最近公共祖先" class="headerlink" title="4、二叉树查找树中两个节点的最近公共祖先"></a>4、二叉树查找树中两个节点的最近公共祖先</h2><p>两个节点 p q，值分别为 p.val q.val<br>若当前节点root的值在root.val在p q值之间，即root为p q的公共祖先<br>若root的值比p、q的值都大，则p、q的祖先在root 的左子树上<br>若root的值比p、的值都小，则p、q的祖先在root 的右子树上</p>
<pre><code>public TreeNode lowestCommonAncestor(TreeNode root , TreeNode p , TreeNode q){
    if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left , p , q);
    if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right , p , q);
    return root;
}</code></pre><h2 id="5、二叉树中两个两个节点的最低公共祖先"><a href="#5、二叉树中两个两个节点的最低公共祖先" class="headerlink" title="5、二叉树中两个两个节点的最低公共祖先"></a>5、二叉树中两个两个节点的最低公共祖先</h2><p>对于p、q两个节点，从根节点root开始遍历，若root等于p、q中的某个，则其为公共祖先。否则分别递归左右子树，若一个节点在左子树上一个节点在右子树上<br>则root为公共结点，若两个节点都在左子树上，则最低公共祖先在左子树上，右子树同理。</p>
<pre><code>public TreeNode lowestCommonAncestor(TreeNode root , TreeNode p , TreeNode q){
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left , p , q);
    TreeNode right = lowestCommonAncestor(root.right , p , q);
    //以下内容也可写为三目运算符
    if(left!=null&amp;&amp;right!=null) return root;
    else if(left!=null) return left;
    else if(right!=null) return right;
    else return null;
    //以上内容也可写为三目运算符:
    return left == null ? right : right == null? left : root;
    //left为null 时返回right,不为空时判断right是否为null, right为null则返回left 否则返回root;
}</code></pre><h2 id="6、将有序数组变为二叉查找树"><a href="#6、将有序数组变为二叉查找树" class="headerlink" title="6、将有序数组变为二叉查找树"></a>6、将有序数组变为二叉查找树</h2><p>把数组中点看做根，讲数组分为左右子树，再对左右子树做同样操作,类似二分查找。</p>
<pre><code>public TreeNode sortedArraytoBST(int [] num){
    if(num == null|| num.length == 0)return null;
    return help(num , 0 , num.length - 1);
}
private TreeNode helper(int []num , int l , int r){
    if(l&gt;r) return null;
    int m = (l+r)/2;
    TreeNode root = new TreeNode(num[m]);
    root.left = helper(num, l , m-1);
    root.right = helper(num, m+1 , r);
    return root;
}</code></pre><h2 id="7、根据有序链表构造平衡的二叉查找树"><a href="#7、根据有序链表构造平衡的二叉查找树" class="headerlink" title="7、根据有序链表构造平衡的二叉查找树"></a>7、根据有序链表构造平衡的二叉查找树</h2><p>取巧解法：先把有序链表转换为有序数组，问题就变成了有序数组构造二叉查找树问题即(6)<br>普通解法：定义函数，使用快慢指针，可以找到链表的中点。有了这个函数就可以和之前的有序数组构造二叉查找树问题类似了。<br>快慢指针找链表的中点有两种写法</p>
<pre><code>ListNode fast = head;
ListNode slow = head;
while(fast!=null){
    fast = fast.next;
    slow = slow.next;
    if(fast==null)break;
    fast = fast.next;
}</code></pre><p>//上面这种写法偶数个节点时slow指向中点右侧，奇数个节点时slow指向中间节点的下一个节点<br>例： 1 2 3 4 5 6<br>a: fast:1 slow:1<br>b: fast:2 slow:2 fast:3<br>c: fast:4 slow:3 fast:5<br>d: fast:6 slow:4 fast:null<br>e: 循环退出</p>
<p>例： 1 2 3 4 5 6 7<br>a: fast:1 slow:1<br>b: fast:2 slow:2 fast:3<br>c: fast:4 slow:3 fast:5<br>d: fast:6 slow:4 fast:7<br>e: fast:null slow:5  fast==null break;循环退出</p>
<pre><code>ListNode slow = head;
ListNode fast = head.next;
while(fast!=null &amp;&amp; fast.next!=null){
    slow = slow.next;
    fast = fast.next.next;
}</code></pre><p>//上面这种写法偶数个节点时slow指向中点左侧，奇数个节点时slow指向中间节点<br>例： 1 2 3 4 5 6<br>a: slow:1 fast:2<br>b: slow:2 fast:4<br>c: slow:3 fast:6<br>d: fast.next==null,循环停止</p>
<p>例： 1 2 3 4 5 6 7<br>a: slow:1 fast:2<br>b: slow:2 fast:4<br>c: slow:3 fast:6<br>d: slow:4 fast:null<br>e: fast==null,循环停止</p>
<pre><code>private ListNode getPreMid(ListNode node){
    ListNode slow = head;
    ListNode fast = head.next;
    ListNode pre = head;
    while(fast!=null &amp;&amp; fast.next!=null){
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    return pre;//本题所找到的pre 是slow节点的前一个节点,以便后续操作时同时取到中点和中点前一个节点
}
public TreeNode sortedListToBST(ListNode head){
    if(head == null)return null;
    if(head.next == null) return new TreeNode(head.val);//若链表只有一个节点，则直接将其变为二叉树节点即可。
    ListNode preMid = getPreMid(head);
    ListNode mid = preMid.next;
    preMid.next = null;//调用getPreMid函数获得了有序链表的中点和中点的前一个节点后，将链表从中点断开，问题变为两个链表的子问题，
                       //左边子问题的初始节点仍然为head,将mid转化为二叉树节点,右边子问题的初始节点为mid.next
    TreeNode t = new TreeNode(mid.val);
    t.left = sortedListToBST(head);
    t.right = sortedListToBST(mid.next);
    return t;
}</code></pre><h2 id="8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值"><a href="#8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值" class="headerlink" title="8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值"></a>8、判断二叉查找树中是否可寻找到两个节点，使它们之和为一个给定数值</h2><p>twosum问题的变体，解题方法是在有序数组中使用双指针，二叉查找树中序遍历即可变为有序数组</p>
<pre><code>private void inOrder(TreeNode node , List&lt;Integer&gt; nums){
    if(root == null)return;
    inOrder(root.left,nums);
    nums.add(root.val);
    inOrder(root.right,nums);
}//中序遍历把二叉查找树转为有序数组并存于nums中
public boolean findTarget(TreeNode root, int k){
    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    inOrder(root , nums);
    int i = 0 , j = nums.size() - 1;
    while(i &lt; j){
        if(nums.get(i)+nums.get(j)==k) {return true;}
        else if(nums.get(i)+nums.get(j)&gt;k){
        j--;
        }
        else{
            i++;
        }
    }
    return false;
}</code></pre><h2 id="9、在二叉查找树中查找两个节点之差的最小绝对值"><a href="#9、在二叉查找树中查找两个节点之差的最小绝对值" class="headerlink" title="9、在二叉查找树中查找两个节点之差的最小绝对值"></a>9、在二叉查找树中查找两个节点之差的最小绝对值</h2><p>中序遍历，遍历时取某一节点和其前一个节点，计算差值，取最小。</p>
<pre><code>private int minDiff = Integer.MAX_VALUE;
private TreeNode preNode = null;
private void inOrder(TreeNode node){
    if(node == null) return;
    inOrder(node.left);
    if(preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);
    preNode = node;
    inOrder(node.right);
}
public int getMinimumDifference(TreeNode root){
    inOrder(root);
    return minDiff;
}</code></pre><h2 id="10、寻找二叉查找树中出现次数最多的值"><a href="#10、寻找二叉查找树中出现次数最多的值" class="headerlink" title="10、寻找二叉查找树中出现次数最多的值"></a>10、寻找二叉查找树中出现次数最多的值</h2><pre><code>private int curCnt = 1;
private int MaxCnt = 1;
private TreeNode preNode = null;
public int [] findMode(TreeNode root){//中序遍历得到结果存入maxCntNums中再将其转化为数组ret
    List&lt;Integer&gt; maxCntNums = new ArrayList&lt;&gt;();
    inOrder(root,maxCntNums);
    int [] ret = new int[maxCntNums.size()];
    int idx = 0;
    for(int num: maxCntNums){
    ret[idx++] = num;
    }
    return ret;
}
private void inOrder(TreeNode node , List&lt;Integer&gt; nums){
    if(node ==null )return;
    inOrder(node.left, nums);
//累计相同数字出现次数
    if(preNode != null){
        if(preNode.val==node.val) curCnt++;
        else curCnt = 1;
    }
//若当前数字出现次数大于最大出现次数，则更新
    if(curCnt &gt; maxCnt){
        maxCnt = curCnt;
        nums.clear();
        nums.add(node.val);
    }else if (curCnt == maxCnt){//若当前数字出现次数等于最大出现次数，则增加一个众数
        nums.add(node.val);
    }
    preNode = node;
//
    inOrder(node.right,nums);
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" data-id="ck9gmopt00003e0rg3nqyf4q8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-二叉树类算法题2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/" class="article-date">
  <time datetime="2020-04-18T04:43:41.531Z" itemprop="datePublished">2020-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/">二叉树类算法题2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h2><p>求一棵树每层节点的平均数</p>
<pre><code>public List&lt;Double&gt; averageOfLevels(TreeNode root){
    List&lt;Double&gt; ret new ArrayList&lt;&gt;();
        //ret用来存储每层节点的平均数
    if (root == null) return ret;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        //用一个队列queue来存储当前层的所有节点
    queue.add(root);
    while(!queue.isEmpty()){
        int cnt = queue.size();
        //当前层节点压入队列之后，队列大小即节点数
        double sum = 0;//用来累加当前层的节点和
        for(int i = 0 ; i &lt; cnt ; i++){
            TreeNode node = queue.poll();
            sum += node.val;
            if(node.left != null) queue.add(node.left);
            if(node.right != null) queue.add(node.right);
        }
        ret.add(sum/cnt);
        //sum/cnt即某层的节点平均数，压入ret中
    }
    return ret;
}</code></pre><h2 id="求二叉树最下层的最左边的结点。"><a href="#求二叉树最下层的最左边的结点。" class="headerlink" title="求二叉树最下层的最左边的结点。"></a>求二叉树最下层的最左边的结点。</h2><p>层序遍历时，从右往左的向队列中压入一整层的节点,再出队列。则最后一个出队列的节点是最底层的最左边节点。</p>
<pre><code>public int findBottomLeftValue(TreeNode root){
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while(!queue.isEmpty()){
        root = queue.poll();
        if(root.right!=null) queue.add(root.right);
        if(root.left!=null) queue.add(root.left);
    }
    return root.val;
}</code></pre><h2 id="二叉树前序遍历："><a href="#二叉树前序遍历：" class="headerlink" title="二叉树前序遍历："></a>二叉树前序遍历：</h2><p>需要借助栈，因为前序遍历是  root -&gt; left -&gt; right<br>而栈是后进先出，所以为达到遍历过程中的先左后右，必须要使得压栈过程先右后左。</p>
<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root){
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        //空节点不记录入ret中，它无左右节点，也不需要将左右节点压栈
        //当空节点被压入栈中时，说明上一次出栈操作的root为叶子节点或只有左右节点中的一个。
        //若无这一步，不对node做null判断，每次常规的压栈操作，会将叶子节点的左右节点(均为空)
        //或只有一个孩子节点的节点的左右节点(有一个为空)均压入栈中后记录,即在最终的遍历结果中出现很多null且无法退出遍历。
        //有了这一步判断，仍然会在上一层循环中压入null，但进行一次判断后，null节点的左右孩子节点(仍为null)不会再压入栈中，
        //null节点也不会计入ret中。而是遇到null之后做弹栈操作。弹到非null节点为止。
        ret.add(node.val);
        stack.push(root.right);//顺序很重要
        stack.push(root.left);//顺序很重要
    }
    return ret;
}</code></pre><h2 id="二叉树的后序遍历："><a href="#二叉树的后序遍历：" class="headerlink" title="二叉树的后序遍历："></a>二叉树的后序遍历：</h2><p>后序遍历可以通过前序遍历修改。<br>前序遍历是  root -&gt; left -&gt; right<br>后序遍历是  left -&gt; right -&gt; root<br>将前序遍历改为 root -&gt; right -&gt; left 再逆序即可。</p>
<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root){
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        if(node == null) continue;
        ret.add(node.val);
        stack.push(root.left);
        //前序遍历时先压右节点再压左节点保证先出左节点后出右节点
        stack.push(root.right);
        //后序遍历时，与之相反，最后要将结果逆置
    }
    Collections.reverse(ret);
    return ret;
}</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root){
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if(root == null) return ret;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode cur = root;
    while(cur!=null || !stack.isEmpty()){
        while(cur != null){
        stack.push(cur);
        cur = cur.left;
        }
        //中序遍历 left -&gt; root -&gt; right，所以每次压栈要将left压到底为止
        TreeNode node = stack.pop();
        ret.add(node.val);
        cur = node.right;
        //压栈完，进行弹栈操作并记录后再压入node.right，即在root之后记录right
    }
    return ret;
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/" data-id="ck9gmopt40005e0rgh1lu04sl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-二叉树类算法题1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%981/" class="article-date">
  <time datetime="2020-04-02T06:50:46.695Z" itemprop="datePublished">2020-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%981/">二叉树类算法题1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>二叉树类题目多考虑递归，在处理完root之后，root的左右子树的处理方法都是一致的，处理root过程中，要先考虑到各种null情况。</p>
<h2 id="二叉树两节点的最长路径"><a href="#二叉树两节点的最长路径" class="headerlink" title="二叉树两节点的最长路径"></a>二叉树两节点的最长路径</h2><p>二叉树的两节点的最长路径，要么两节点都在左子树上，要么两节点都在右子树上，要么一个节点在左子树一个节点在右子树，若一个节点在左子树一个节点在右子树，即求左右子树不包括根节点的高度和+1<br>故根结点为root的二叉树的两节点最长路径 = Max(左子树的最长路径，右子树的最长路径，左子树深度(去根)+右子树深度(去根)+1)即<br>    public class solution {<br>    int max = 0;<br>    public int diameterOfBinaryTree(TreeNode root){<br>        getDepth(root);<br>        return max;<br>    }</p>
<pre><code>private int getDepth(TreeNode root){//返回树的最大深度
    if(root == null)
    return 0;
    int l = getDepth(root.left);
    int r = getDepth(root.right);
    int max = Math.max(max , l+r);
    return Math.max(l,r)+1;
    }
}</code></pre><h2 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树 "></a>反转二叉树 </h2><p>常见的递归操作题<br>    public TreeNode invertTree(TreeNode root){<br>        if(root == null) return null;<br>        TreeNode left = root.left;//记录root.left防止丢失<br>        root.left = invertTree(root.right);<br>        root.right = invertTree(left);<br>        return root;<br>    }</p>
<h2 id="归并两棵二叉树"><a href="#归并两棵二叉树" class="headerlink" title="归并两棵二叉树"></a>归并两棵二叉树</h2><pre><code>public TreeNode MergeTree(TreeNode tree1 , TreeNode tree2){
    if(tree1 == null &amp;&amp; tree2 == null)return null;
    if(tree1 == null) return tree2;
    if(tree2 == null) return tree1;
    TreeNode root = new TreeNode(tree1.val + tree2.val);
    root.left = MergeTree(tree1.left, tree2.left);
    root.right = MergeTree(tree1.right , tree2.right);
    return root;
}</code></pre><h2 id="判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径"><a href="#判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径" class="headerlink" title="判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径"></a>判断二叉树中是否存在从根结点到叶子结点的和为目标数的路径</h2><p>路径要么在左子树上，要么在右子树上。<br>走向左右子树后，目标数减去根结点数值，对左右子树做递归。<br>因为必须要走到叶子结点后结束，即当前节点没有左右节点时判断是否为目标数。</p>
<pre><code>public boolean hasPathsum(TreeNode root , int sum){
    if(root == null) return false;
    if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true;
    return hasPathsum(root.left,sum-root.val) || hasPathsum(root.right, sum-root.val);
}</code></pre><h2 id="统计二叉树中路径和等于目标数的路径数量"><a href="#统计二叉树中路径和等于目标数的路径数量" class="headerlink" title="统计二叉树中路径和等于目标数的路径数量"></a>统计二叉树中路径和等于目标数的路径数量</h2><p>不需要从根节点起到叶子节点止，但需要连续。</p>
<p>整个判断过程，先从根节点开始走路径，然后递归左右子节点。<br>判断过程中，省去了验证最后一个结点为叶子结点的过程。<br>然后再做一次递归，从这个根节点的左右子树开始判断，以左右子树为根结点再判断一次是否符合题意。即本题有两种递归，一种是递归的判断以某点作为起点是否存在路径，一种是递归的找起点。</p>
<pre><code>public int pathSum(TreeNode root , int sum){//这个函数是递归的找起始节点。
    if(root == null) return 0;
    int result = pathSumStartWithRoot(root,sum)+pathSum(root.left , sum)+pathSum(root.right , sum);
    return result;
}

private int pathSumStartWithRoot(TreeNode root , int sum){//这个函数可以判断出从根节点开始的路径和是否满足目标数
    if(root == null) return 0;
    int result = 0;
    if(root.val == sum) result ++;
    result += pathSumStartWithRoot(root.left , sum - root.val) + pathSumStarrtWithRoot(root.right , sum - root.val);
    return result;
}</code></pre><h2 id="判断A树是否为B树的子树"><a href="#判断A树是否为B树的子树" class="headerlink" title="判断A树是否为B树的子树"></a>判断A树是否为B树的子树</h2><p>若A树是B树的子树，那必和B树的一部分相等,以下为判断两树是否相等<br>方法：若都为null，则相等，若只有一个为null，则不相等，若数值不同则不相等，递归对比他们的左右子树。</p>
<p>判断A树是否和B树相等之后，再递归比较A树是否和B树的左右子树相等即可判断A树是否是B树的子树,当B树为null时递归退出</p>
<pre><code>public boolean isSubtree(TreeNode A , TreeNode B){
    if(B==null) return false;
    return isSame(A,B)||isSubtree(A,B.left)||isSubtree(A,B.right);
}
private boolean isSame(TreeNode A,TreeNode B){
    if(A == null &amp;&amp; B == null) return true;
    if(A == null || B == null) return false;
    //都为空排除后的或证明了一个为空一个不为空
    if(A.val != B.val) return false;
    return isSame(A.left,B.left)&amp;&amp;isSame(A.right,B.right);
}</code></pre><h2 id="判断一个树是否左右对称"><a href="#判断一个树是否左右对称" class="headerlink" title="判断一个树是否左右对称"></a>判断一个树是否左右对称</h2><p>此题和子树判断题类似，可以将左右对称变为判断两个树是否相等</p>
<pre><code>public boolean isSymmetric(Tree root){
    if(root==null) return true;//之所以null时返回true是因为比对到null则说明递归到底，比对成功了
    return isSame(root.left, root.right);
}</code></pre><h2 id="树的最小路径"><a href="#树的最小路径" class="headerlink" title="树的最小路径"></a>树的最小路径</h2><pre><code>public int minDepth(TreeNode root){
    if(root == null) return 0;//若这个树为空则高度为0
    if(root.left == null &amp;&amp; root.right == null) return 1;//若这个树左右子树同时为空则高度为1
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    if(leftDepth == 0)
    //若这个树左子树为空，则长度为右子树长度+1
        return rightDepth + 1;
    else if(rightDepth == 0)
    //若这个树右子树为空，则长度为左子树长度+1
        return leftDepth + 1;
    else
        return min(leftDepth,rightDepth) + 1;
     //若左右子树都不为空，则长度为左右子树的较小值+1
 }</code></pre><p>以上代码可优化为</p>
<pre><code>public int minDepth(TreeNode root){
    if(root == null)return 0;
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    if(leftDepth == 0 || rightDepth == 0) {
        return leftDepth+rightDepth+1;
    }
    //leftDepth和rightDepth都不为0才返回下一御酒
    return Math.min(leftDepth,rightDepth)+1;
}</code></pre><h2 id="统计左叶子节点的和"><a href="#统计左叶子节点的和" class="headerlink" title="统计左叶子节点的和"></a>统计左叶子节点的和</h2><p>//若一个结点的左孩子是叶节点，即他的左孩子是左叶子结点，累加左孩子数值之后再递归判断这个结点的右子树<br>//否则，递归判断这个结点的左右子树</p>
<pre><code>public int sumOfLeftLeaves(TreeNode root){
    if(root == null) return 0;
    if(isLeaf(root.left)){
        return root.left.val + sumOfLeftLeaves(root.right);
    }
    return sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);
}
//判断一个节点是不是叶子节点
private boolean isLeaf(TreeNode node){
    if(node == null) return false;
    return node.left == null &amp;&amp; node.right == null;
}</code></pre><h2 id="相同结点值的最大路径长度"><a href="#相同结点值的最大路径长度" class="headerlink" title="相同结点值的最大路径长度"></a>相同结点值的最大路径长度</h2><p>需要用到深度优先搜索</p>
<p>树的递归题目中，写出的左右子节点的递归，可以默认写出时即已经是正确的结果，再进行后续。</p>
<pre><code>private int path = 0;
public int longestUnivaluePath(TreeNode root){
    dfs(root);
    return path;
}
private int dfs(TreeNode root){
    if(root == null)return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    //dfs的子函数return的值可从 最外层的dfs看出。
    // Math.max(leftPath,rightPath)即，返回的是 左路径和右路径中的较大值。
    //即 left返回的是 root左节点 的左右路径中的较大值
    // right 返回的是root右节点 的左右路径中的较大值
    int leftPath = root.left!=null &amp;&amp; root.left.val == root.val ? left+1 : 0;
    int rightPath = root.right!=null &amp;&amp; root.right.val == root.val ? right+1 : 0;
    //获得了左右子节点的左右路径中的较长者之后，对于当前的root节点而言，若root节点的值和左节点相等，则左路径+1，类似的右路径+1。
    path = Math.max(path,leftPath + rightPath);
    //path用来记录并更新一个以root为根结点的树的相同节点最大路径长度
    return Math.max(leftPath,rightPath);
    //所返回的值是之前计算过的左右路径中的较大值。
}</code></pre><h2 id="House-Robber-III"><a href="#House-Robber-III" class="headerlink" title="House Robber III"></a>House Robber III</h2><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police<br>间隔遍历：在二叉树中取点，要求任意两点不相邻，求所取点之和的最大值为多少。</p>
<p>对于root为根的二叉树，最优解为取根结点+四个孙子节点或 取两个孩子结点之间的较大值。即</p>
<p>f(root) = max(root.val + f(ll) + f(lr) + f(rl) + f(rr) , f(l)+f(r))</p>
<pre><code>public int rob(TreeNode root){
    if(root == null) return 0;
    int val1 = root.val;
    if(root.left!=null){
    val1 = val1 + rob(root.left.left) + rob(root.left.right); 
    }
    if(root.right!=null){
    val1 = val1 + rob(root.right.left) + rob(
    root.right.right);
    }
    int val2 = rob(root.left)+rob(root.right);
    return Math.max(val1,val2);
}</code></pre><h2 id="求二叉树中第二小的值"><a href="#求二叉树中第二小的值" class="headerlink" title="求二叉树中第二小的值"></a>求二叉树中第二小的值</h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>
<p>1、定义两个变量，一个保存最小值一个保存次小值。再定义一个flag递归过程中，若找到过次小值则改变flag，返回次小值。若未找到过次小值，则返回-1；</p>
<pre><code>int first = Integer.MAX_VALUE, second = Integer.MAX_VALUE;
int flag = 0;
public int findSecondMinimumValue(TreeNode root){
    helper(root);
    return flag == 0 ? -1:second;
}
public void helper(TreeNode root){
    if(root == null)
    return ;
    if(root.val &lt; first){
        second = first;
        first = root.val;
    }else if(root.val &lt;= second &amp;&amp; root.val &gt; first){
        flag++;
        second = root.val;
    }
    helper(root.left);
    helper(root.right);
}</code></pre><p>2、因为这个二叉树父节点的值必≤子节点的值，故根结点必定为最小值，所以第二小的值必在左右两个子树之中，<br>倘若左右两个子树中的最小值都不和根结点相等，则第二小的值是左右两个子树最小值中的较小值。<br>倘若左(右)子节点和父节点的值相等，则需要在左(右)子树中找出第二小的值来与右(左)子树的最小值一起比较出一个较小值出来。这样才能保证比对出来的是真正的第二小的值。<br>简而言之，要在左右子树中分别找出和根结点不相等的最小值。<br>这两个最小值中的较小者就是第二小的值。</p>
<p>若左(右)子节点和根节点相等，才需要递归的找左(右)子树的次小值。<br>因为左右子树作为一个单独的树做此题的判断，root.left必定是left树的最小值，递归后找到的次小值也即左子树除根结点外的最小值。<br>否则直接取左右子节点中的较小值即可。</p>
<pre><code>public int findSecondMinimumValue(TreeNode root){
    if(root == null) return -1;
    //递归返回条件 1 节点为空，树没有次小值。
    if(root.val==null &amp;&amp; root.right == null) return -1;
    //递归返回条件 2 节点没有子节点，树没有次小值。
    int leftVal = root.left.val;
    int rightVal = root.right.val;
    if(leftVal == root.val) {
        leftVal ==     findSecondMinimumValue(root.left);
    }
    if(rightVal == root.val){
        rightVal == findSecondMinimumValue(root.right);
    }
    if(leftVal != -1 &amp;&amp; rightVal != -1){
        return Math.min(leftVal,rightVal);
        //递归返回条件 3 因为左右节点若与根结点相等则会继续递归，递归到找到没有子节点的节点 返回-1为止。
        //若都不为 -1 则说明两边都没有一直递归到树的末端，而是在中途由于某个子节点不和父节点相等而返回
        //即满足，左右子节点都不和父节点的值相等。
        //那么这两个数值中的较小值就是整个树的次小值。
    }
    if(leftVal != -1) return leftVal;
    // 递归返回条件4 在上一步判断完了两个子节点都不和根结点相等之后，再继续执行则说明，必有一个子节点和根结点值相等，此时若 左子节点不为-1，即左子节点不和根结点相等，即右子节点和根节点相等，此时次小值为左子节点。
    return rightVal;
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%981/" data-id="ck9gmqefd00000srg5fjg27dd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-03-24T15:45:57.821Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="交换链表中的相邻结点"><a href="#交换链表中的相邻结点" class="headerlink" title="交换链表中的相邻结点"></a>交换链表中的相邻结点</h2><p>要求：不允许改变结点的数值<br>[1]-&gt;[2]-&gt;[3]-&gt;[4] 变为[2]-&gt;[1]-&gt;[4]-&gt;[3]</p>
<p>pre 和 next 用于记录交换中的结点中的前后结点。</p>
<p>在头结点之前申请一个结点：node，用于函数返回<br>再申请pre结点，用于交换操作：ListNode pre=node。<br>需要交换的结点为pre其后一位的结点和其后两位的结点即pre.next 和 pre.next.next<br>申请 结点l1 = pre.next和l2 = pre.next.next以方便交换操作。<br>申请 next结点用于记录 pre.next.next的后一个结点，以便交换操作进行后可以找到其后的结点，进行下一步交换操作。<br>l1 和 l2需要进行交换，<br>即令l1.next = next ;//交换操作进行后，l1在后，所以用l1来连接next结点<br> l2.next = l1;//完成l2和l1交换的操作。<br>为保证交换操作后，前链不断<br>pre.next = l2//因为l2已和l1交换，此时l2在前。<br>pre结点作为待交换的两个结点的前一个结点，在一次交换进行之后，需要放在下一个待交换结点对的前一个结点，即本次交换结点中靠后的那一个，即令pre = l1；<br>故完整逻辑为：</p>
<pre><code>ListNode node =new ListNode(-1)
node.next = head;
ListNode pre = node;
While(pre.next!=null &amp;&amp; pre.next.next!=null){
ListNode l1 = pre.next;
ListNode l2 = pre.next.next;
ListNode next = l2.next;
l1.next = next;
l2.next = l1;
pre.next = l2;
pre = l1
}
return node.next </code></pre><h2 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h2><p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7<br>由于数字加法是从尾到头，因为栈的后进先出特性，可以借助栈进行操作。<br>0、声明head作为结果链表的头： ListNode head = new ListNode(-1);<br>1、    将两链表全部压入栈中<br>2、    对两个栈进行一次弹出pop操作，用x和y分别记录弹出元素,声明 carry = 0记录进位。<br>3、    xy求和，sum = x+y+carry<br>4、    声明新结点记录所得结果ListNode node = new ListNode(sum%10);进位carry = sum/10，<br>5、    因为弹出结点从尾到头，所以需要对所有求得的结点进行头插操<br>即node.next = head.next; head.next = node</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" data-id="ck9gmopt90007e0rgewk8bxom" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-myFirstBlog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/12/myFirstBlog/" class="article-date">
  <time datetime="2019-11-12T07:30:02.000Z" itemprop="datePublished">2019-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/12/myFirstBlog/">多模态论文阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>讨论 多模态数据中普遍存在的失配准问题以及模态间的信息缺失问题。<br>数据集：KAIST<br>    CVC-14<br>1、深度卷积神经网络的不同阶段对两个模态的信息进行融合。<br>Multispectral Deep Neural Networks for Pedestrian Detection</p>
<p>2、通过映射矩阵的作用，使得网络能够在最后一层得到三个特征图，分别对应于两个模态各自的特征以及两个模态的融合特征，旨在充分融合两个模态信息的基础上，保留各自模态的特有信息。<br>Correlated and Individual Multi-Modal Deep Learning for RGB-D Object Recognition</p>
<p>3、保留两个模态各自的特有信息，基于概率的思想在网络中加入两个模块，其中一个用来输出当前的输入图像对两个模态各自的特征以及融合特征的依赖程度，另一个模块借助上一个模块的输出作为权重，对来自两个模态各自的输出结果以及基于融合特征输出结果进行加权求和，得到最终的判别概率。<br>Unified Multi-spectral Pedestrain Detection Based on Probabilistic Fusion Networks</p>
<p>4、多模态的迁移学习、域适应</p>
<p>不同模态图像的信息缺失：体现出互补性和多模态数据引入的必要性。</p>
<p>5、双模态数据融合问题可以转化为在哪个特征层进行特征融合的问题<br>四种方法分别为:<br>1、在第一块卷积层之后将来自不同模态的特征图进行融合。融合方式为串接后通过1x1的卷积，将串接后的特征图进行融合并降低到原来的维度。<br>2、在第四个卷积块之后融合。<br>3、在第五个卷积块之后融合。<br>4、在第二个全连接层之后进行融合。</p>
<p>多尺度目标检测<br>1、基于图像金字塔的多尺度目标检测<br>2、基于特征金字塔的多尺度目标检测<br>结合多个卷积层后的特征图，得到一个包含了来自多个卷积层的特征信息的新的特征图。，之后在这个包含多层特征信息的特征图上进行目标检测。<br>直接在多个卷积层后的特征图上进行目标的检测，最终检测结果为全部检测结果的综合。<br>在多模态目标检测网络中加入多尺度处理的步骤<br>将两个模态各自使用的VGG16的第一个、第三个、第五个卷积块后的特征图进行拼接，之后再将两个模态的特征图进行融合。</p>
<p>多模态数据的互补性验证(对比试验)</p>
<p>分步训练方法<br>多模态数据存在信息缺失，使用分步的网络训练方法，<br>1、挑出 Valid-T Valid-RGB两个子数据集</p>
<p>2、使用两个子数据集分别训练两个单模态的检测网络</p>
<p>3、将第二步得到的两个单模态网络的卷积层参数加载到多模态融合网络之中。</p>
<p>展望：从网络结构入手，加入特殊模块，使得多模态检测网络对于数据之间的失配准的敏感性降低。<br>通过网络改进或数据集标注方法的调整来实现便捷的端到端的训练方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/12/myFirstBlog/" data-id="ck9gmopsx0002e0rgd1asg75b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-上采样反向融合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/12/%E4%B8%8A%E9%87%87%E6%A0%B7%E5%8F%8D%E5%90%91%E8%9E%8D%E5%90%88/" class="article-date">
  <time datetime="2019-11-12T07:30:02.000Z" itemprop="datePublished">2019-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/12/%E4%B8%8A%E9%87%87%E6%A0%B7%E5%8F%8D%E5%90%91%E8%9E%8D%E5%90%88/">SSD上采样反向融合笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、为改善光照条件遮挡严重等环境，使用Kinect深度相机，引入深度图，利用多模态数据之间的互补性丰富特征，有效提升行人检测的精度。以行人检测算法ACF为基础，在RGB-D Person Databse 数据集上引入深度图。<br>2、结合行人检测的特点，改善非极大性抑制机制，利用位置和置信度综合判断，对检测框进行重复利用和有效抑制。INRIA数据集<br>3、针对回归精度不高和小目标检测效果差，提出上采样反向特征融合网络，将高层特征与低层特征进行有效融合和激活。</p>
<p>检测问题有别于单纯的分类问题，分类问题不关注与图像占比问题，目标占据图像主要部分，所以一般网络模型越深，提取的特征越丰富，分类性能越好。而检测分为分类和定位两个子问题。且可能包含多个大小不一的目标，正确分类小目标需要更高层的语义信息，正确定位小目标需要高层所不具备的底层细节特征，如何解决这个问题是改善小目标的关键。</p>
<p>作者在SSD算法中通过上采样反向融合方法，将高层特征层和低层特征进行有效的融合和激活。</p>
<p>上采样反向融合网络框架<br>conv4_3经过卷积和池化得到conv5，感受野增大、分辨率减半。<br>本文将conv5 经过一个卷积层，然后利用转置卷积进行特征图上采样至与conv4_3分辨率一样大，在保留conv5卷积层大感受野、高层语义信息的同时恢复出部分丢失的细节信息，然后这个上采样的特征图与conv4_3特征图进行融合，利用1*1的卷积进行特征权重学习，最后将融合后的特征图进行激活得到conv4_r,既保留了conv4_3层的细节信息，又继承了conv5层的语义信息。特征更加丰富，适合用来检测和定位小目标。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/12/%E4%B8%8A%E9%87%87%E6%A0%B7%E5%8F%8D%E5%90%91%E8%9E%8D%E5%90%88/" data-id="ck9gmopt20004e0rg0e899n4c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/12/hello-world/" class="article-date">
  <time datetime="2019-11-12T07:22:10.980Z" itemprop="datePublished">2019-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/12/hello-world/" data-id="ck9gmopsu0001e0rg1nd53b8v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/26/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%E7%AE%97%E6%B3%95%E9%A2%98/">贪心思想算法题</a>
          </li>
        
          <li>
            <a href="/2020/04/25/Markdown%E5%86%99%E4%BD%9C/">Markdown写作</a>
          </li>
        
          <li>
            <a href="/2020/04/25/%E5%AD%97%E5%85%B8%E6%A0%91Trie/">字典树Trie</a>
          </li>
        
          <li>
            <a href="/2020/04/24/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>
          </li>
        
          <li>
            <a href="/2020/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%982/">二叉树类算法题2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>